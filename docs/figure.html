<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>memorizeit.figure API documentation</title>
<meta name="description" content="Figure â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>memorizeit.figure</code></h1>
</header>
<section id="section-intro">
<h3 id="figure">Figure</h3>
<p>This module contains figures representation both 2D (<code>pygame</code>) and 3D
(<code>OpenGL</code>). It covers all necessary information as points for 2D figures,
edges, vertices, surfaces for 3D figures. It is also responsible for creating
waves of elements based on <code>random</code> module.</p>
<p>License:
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L0-L720" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;### Figure

This module contains figures representation both 2D (`pygame`) and 3D
(`OpenGL`). It covers all necessary information as points for 2D figures,
edges, vertices, surfaces for 3D figures. It is also responsible for creating
waves of elements based on `random` module.

License:
THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
&#34;&#34;&#34;

from OpenGL.GL import (glBegin, glColor3fv, glVertex3fv, glEnd,
                       GL_LINES, GL_QUADS)
import pygame
from random import choice, choices, randrange, randint, sample

from memorizeit import colors


class Wave:
    &#34;&#34;&#34;
    A class with collection of the same methods both for Wave2D and Wave3D.

    It is base, responsible for creating wave of elements, iterating through
    its objects, counting and calling them (drawing).

    ...

    Attributes
    ----------
    figure_type : str
        name of figures which will be in the wave
    color : tuple or pygame.Surface or False
        RGB code of color for wave (0-1, 0-1, 0-1), False if each element in
        wave will have his own color or pygame.Surface in case if photo will
        be used as displayed element
    *args
        rest of parameters needed to create specified type of wave, see Wave2D
        and Wave3D
    &#34;&#34;&#34;

    def __init__(self, figure_type, color, *args):
        &#34;&#34;&#34;Initialize wave.

        Parameters
        ----------
        figure_type : str
            name of figures which will be in the wave
        color : tuple or pygame.Surface or False
            RGB code of color for wave (0-1, 0-1, 0-1), False if each element
            in wave will have his own color or pygame.Surface in case if photo
            will be used as displayed element
        *args
            rest of parameters needed to create specified type of wave, see
            Wave2D and Wave3D
        &#34;&#34;&#34;
        self.figure = figure_type
        self.figures = []
        self.fill(color, *args)

    def __repr__(self):
        &#34;&#34;&#34;Return `Wave` class representation.&#34;&#34;&#34;
        name = self.__class__.__name__
        return f&#39;&lt;{name} of {self.__len__()} {self.figure.lower()}s&gt;&#39;

    def __iter__(self):
        &#34;&#34;&#34;Iterate through wave figures.&#34;&#34;&#34;
        return (x for x in self.figures)

    def __len__(self):
        &#34;&#34;&#34;Return number of wave figures.&#34;&#34;&#34;
        return len(self.figures)

    def __call__(self):
        &#34;&#34;&#34;Spawn (display) wave on screen.&#34;&#34;&#34;
        for figure in self:
            figure()


class Wave2D(Wave):
    &#34;&#34;&#34;
    A class with methods needed to display 2D wave.

    It is responsible for calculating proper points on screen to display
    objects, setting their size, pick amount. Has description how 2D wave
    should be created. It is child of class Wave.

    ...

    Methods
    -------
    get_amount()
        randomly pick number of elements from 1 to 9 according to their weights
    get_mid_points(resolution)
        according to resolution of screen - tuple (width, height) divides
        screen into nine equal fields (net 3x3) and return list with their
        middle points (width, height)
    get_figure_size(resolution)
        according to resolution of screen - tuple (width, height) return
        integer with size of figure
    fill(color, screen, resolution)
        populates figures list with 2D figures objects binded to screen
        (`pygame.Surface`). Use wave color or photo if it is passed else pick
        random color for each element. Resolution is used to set figure size
        and region of screen where it will be displayed
    &#34;&#34;&#34;

    @staticmethod
    def get_amount():
        &#34;&#34;&#34;Pick random number of elements from 1 to 9 according to weights.&#34;&#34;&#34;
        return choices(
            range(1, 10),
            weights=[0.03, 0.1, 0.2, 0.2, 0.2, 0.15, 0.1, 0.01, 0.01]
        )[0]

    @staticmethod
    def get_mid_points(resolution):
        &#34;&#34;&#34;Divide screen in net 3x3 and return middle point of each field.

        Parameters
        ----------
        resolution : tuple
            a tuple with two int values - width, height - according to
            resolution of used monitor

        Returns
        -------
        list
            a list with 9 positions (screen divided in net 3x3) - middle point
            of each part of divided screen
        &#34;&#34;&#34;
        w, h = resolution
        return [(int(x), int(y))
                for x in (w / 6, w / 2, w - w / 6)
                for y in (h / 6, h / 2, h - h / 6)]

    @staticmethod
    def get_figure_size(resolution):
        &#34;&#34;&#34;Return size of figure (used in drawing).

        Parameters
        ----------
        resolution : tuple
            a tuple with two int values - width, height - according to
            resolution of used monitor

        Returns
        -------
        int
            size of figure which will be drawn
        &#34;&#34;&#34;
        w, h = resolution
        return int(min(w / 3, h / 3) / 4)

    def fill(self, color, screen, resolution):
        &#34;&#34;&#34;Populate figures list.

        2D figures objects are created and binded to screen
        (`pygame.Surface`). It uses wave color (RGB code (0-1, 0-1, 0-1) which
        is converted to (0-255, 0-255, 0-255)) or photo if it is passed else
        it picks random color for each element. Resolution is used to set
        figure size and region of screen where it will be displayed. Amount of
        elements in wave is picked randomly according to method get_amount().

        Parameters
        ----------
        color : tuple or pygame.Surface or False
            RGB color code represented as (0-1, 0-1, 0-1) values,
            pygame.Surface if each object will display photo or False in case
            when we don&#39;t want to create wave in solid color, but use random
            color for each object
        screen: pygame.Surface
            object representing game screen where created figures will be
            binded
        resolution : tuple
            a tuple with two int values - width, height - according to
            resolution of used monitor
        &#34;&#34;&#34;
        for point in sample(
                self.get_mid_points(resolution), self.get_amount()):
            figure_color = color if color else colors.Random().get_color()

            if not isinstance(color, pygame.Surface):
                figure_color = colors.convert(figure_color)

            self.figures.append(
                Figure2D(screen, self.figure, figure_color, point,
                         self.get_figure_size(resolution))
            )


class Wave3D(Wave):
    &#34;&#34;&#34;
    A class with method allowing to create 3D wave.

    It fills figure list with proper objects. It is child of class Wave.

    ...

    Methods
    -------
    fill(color, position)
        populates figures list with 3D figures objects. Position Z of camera
        must be specified (how far from beginning figure will be drawn). It
        uses wave color if it is passed else picks random color for each
        element.
    &#34;&#34;&#34;

    def fill(self, color, position_z):
        &#34;&#34;&#34;Populate figures list.

        3D figures objects are created according to randomly generated number
        in range 2-6. It uses wave color (RGB code (0-1, 0-1, 0-1) if it is
        passed else it picks random color for each element. Figures are
        created in normal mode. Easter egg (for those who like to read
        documentation as I do): there is also available fire mode (see
        Figure3D fire @classmethod) which will simulate flames. Be aware that
        each object will be colored same way. Replace `.normal` with `.fire`
        in loop below - where objects are created.

        Parameters
        ----------
        color : tuple or False
            RGB color code represented as (0-1, 0-1, 0-1) or False in case
            when we don&#39;t want to create wave in solid color, but use random
            color for each object
        position_z : int
            position of camera Z where figure will be drawn (how far from
            beginning - where camera started to move)
        &#34;&#34;&#34;
        for _ in range(randint(2, 6)):
            figure_color = color if color else colors.Random().get_color()

            self.figures.append(
                eval(self.figure).normal(position_z, figure_color)
            )


class Figure2D:
    &#34;&#34;&#34;
    A class with methods allowing to display 2D figures on screen.

    ...

    Attributes
    ----------
    screen: pygame.Surface
        object representing game screen where created figure will be binded
    figure : str
        name of created figure
    color : tuple or pygame.Surface
        RGB color code represented as (0-255, 0-255, 0-255) values,
        pygame.Surface if photo is used
    points : list
        list with points needed to draw figure
    &#34;&#34;&#34;

    def __init__(self, screen, figure, color, mid_point, size):
        &#34;&#34;&#34;Initialize 2D figure.

        Parameters
        ----------
        screen: pygame.Surface
            object representing game screen where created figure will be binded
        figure : str
            name of created figure
        color : tuple or pygame.Surface
            RGB color code represented as (0-255, 0-255, 0-255) values,
            pygame.Surface if photo is used
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn
        &#34;&#34;&#34;
        self.screen = screen
        self.figure = figure
        self.color = color
        self.points = self.adjust_points(mid_point, size)

    def __repr__(self):
        &#34;&#34;&#34;Return `Figure2D` class representation.&#34;&#34;&#34;
        return f&#39;&lt;{self.figure} with points: {self.points}&gt;&#39;

    def __call__(self):
        &#34;&#34;&#34;Draw figure or displays photo on screen.&#34;&#34;&#34;
        if isinstance(self.color, pygame.Surface):
            self.screen.blit(self.color, self.points)
        else:
            pygame.draw.polygon(self.screen, self.color, self.points)

    def adjust_points(self, mid_point, size):
        &#34;&#34;&#34;Return points needed to display element.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw or display element on screen (each
            has width and height value)
        &#34;&#34;&#34;
        if isinstance(self.color, pygame.Surface):
            w, h = self.color.get_size()
            return [int(mid_point[0] - w / 2), int(mid_point[1] - h / 2)]
        return eval(&#39;self.get_&#39; + self.figure + &#39;_points&#39;)(mid_point, size)

    @staticmethod
    def get_diamond_points(mid_point, size):
        &#34;&#34;&#34;Return points needed to draw diamond.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw diamond on screen (each has width
            and height value)
        &#34;&#34;&#34;
        x, y = mid_point
        s = size
        return [(x, y - s), (x - s, y), (x, y + s), (x + s, y)]

    @staticmethod
    def get_square_points(mid_point, size):
        &#34;&#34;&#34;Return points needed to draw square.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw square on screen (each has width
            and height value)
        &#34;&#34;&#34;
        x, y = mid_point
        s = size
        return [(x - s, y - s), (x - s, y + s), (x + s, y + s), (x + s, y - s)]

    @staticmethod
    def get_triangle_points(mid_point, size):
        &#34;&#34;&#34;Return points needed to draw triangle.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw triangle on screen (each has width
            and height value)
        &#34;&#34;&#34;
        x, y = mid_point
        s = size
        return [(x - s, y + s), (x + s, y + s), (x, y - s)]

    @staticmethod
    def get_octagon_points(mid_point, size):
        &#34;&#34;&#34;Return points needed to draw octagon.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw octagon on screen (each has width
            and height value)
        &#34;&#34;&#34;
        x, y = mid_point
        s = size
        return [(x - s, y + s / 2), (x - s, y - s / 2), (x - s / 2, y - s),
                (x + s / 2, y - s), (x + s, y - s / 2), (x + s, y + s / 2),
                (x + s / 2, y + s), (x - s / 2, y + s)]


class Figure3D:
    &#34;&#34;&#34;
    A class with methods allowing to display 3D figures on screen.

    ...

    Attributes
    ----------
    color : tuple
        RGB color code represented as (0-1, 0-1, 0-1) values
    mode : OpenGL.constant.IntConstant
        mode used to draw figures in 3D - GL_LINES or GL_QUADS
    operation : function
        method used in specified mode to provide values needed to draw figure
        - get_edges or get_surfaces
    vertices : list
        list filled with vertices needed to draw figure
    &#34;&#34;&#34;

    def __init__(self, position_z, color, mode, operation):
        &#34;&#34;&#34;Initialize 3D figure.

        Parameters
        ----------
        position_z : int
            position of camera Z where figure will be drawn (how far from
            beginning - where camera started to move)
        color : tuple
            RGB color code represented as (0-1, 0-1, 0-1) values
        mode : OpenGL.constant.IntConstant
            mode used to draw figures in 3D - GL_LINES or GL_QUADS
        operation : function
            method used in specified mode to provide values needed to draw
            figure - get_edges or get_surfaces
        &#34;&#34;&#34;
        self.color = color
        self.mode = mode
        self.operation = operation
        self.vertices = self.adjust_vertices(self.get_random_shift(position_z))

    def __repr__(self):
        &#34;&#34;&#34;Return `Figure3D` class representation.&#34;&#34;&#34;
        return f&#39;&lt;{self.__class__.__name__} with vertices: {self.vertices}&gt;&#39;

    def __call__(self):
        &#34;&#34;&#34;Display figure on screen.&#34;&#34;&#34;
        glBegin(self.mode)
        for element in self.operation():
            for vertex in element:
                color = choice(self.color) if all(
                    [isinstance(x, tuple) for x in self.color]
                ) else self.color
                glColor3fv(color)
                glVertex3fv(self.vertices[vertex])
        glEnd()

    @classmethod
    def normal(cls, position_z, color, *args):
        &#34;&#34;&#34;Set class parameters to draw contour of figure in set color.&#34;&#34;&#34;
        return cls(position_z, color, GL_LINES, cls.get_edges)

    @classmethod
    def fire(cls, position_z, *args):
        &#34;&#34;&#34;Set class parameters to draws full figure imitating flame.&#34;&#34;&#34;
        return cls(position_z, ((0.5, 0, 0), (1, 0.5, 0)),
                   GL_QUADS, cls.get_surfaces)

    @staticmethod
    def get_random_shift(position_z):
        &#34;&#34;&#34;Return adjusted point according to moving camera.

        Parameters
        ----------
        position_z : int
            position of camera Z where figure will be drawn (how far from
            beginning - where camera started to move)

        Returns
        -------
        tuple
            containing x, y, z randomized values for point where figure will
            be drawn
        &#34;&#34;&#34;
        x = choice((-1, 1)) * randrange(2, 10)
        y = choice((-1, 1)) * randrange(2, 10)
        z = randrange(int(position_z - 90), int(position_z - 60))
        return x, y, z

    def adjust_vertices(self, point):
        &#34;&#34;&#34;Return adjusted figure vertices according to set point.

        Parameters
        ----------
        point : tuple
            tuple with x, y, z value - position where figure will be drawn

        Returns
        -------
        list
            containing new vertices values allowing to draw 3D figure
        &#34;&#34;&#34;
        new_vertices = []
        for vertice in self.get_vertices():
            new = []
            new.append(vertice[0] + point[0])
            new.append(vertice[1] + point[1])
            new.append(vertice[2] + point[2])
            new_vertices.append(new)
        return new_vertices


class Cube(Figure3D):
    &#34;&#34;&#34;A class representing cube. It extends Figure3D.&#34;&#34;&#34;

    @staticmethod
    def get_vertices():
        &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
        return (
            (1, -1, -1),
            (1, 1, -1),
            (-1, 1, -1),
            (-1, -1, -1),
            (1, -1, 1),
            (1, 1, 1),
            (-1, -1, 1),
            (-1, 1, 1)
        )

    @staticmethod
    def get_edges():
        &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
        return (
            (0, 1),
            (0, 3),
            (0, 4),
            (2, 1),
            (2, 3),
            (2, 7),
            (6, 3),
            (6, 4),
            (6, 7),
            (5, 1),
            (5, 4),
            (5, 7)
        )

    @staticmethod
    def get_surfaces():
        &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
        return (
            (0, 1, 2, 3),
            (3, 2, 7, 6),
            (6, 7, 5, 4),
            (4, 5, 1, 0),
            (1, 5, 7, 2),
            (4, 0, 3, 6)
        )


class Octagon(Figure3D):
    &#34;&#34;&#34;A class representing octagon. It extends Figure3D.&#34;&#34;&#34;

    @staticmethod
    def get_vertices():
        &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
        return (
            (-0.25, 0, -0.5),
            (0.25, 0, -0.5),
            (0.5, 0, -0.25),
            (0.5, 0, 0.25),
            (0.25, 0, 0.5),
            (-0.25, 0, 0.5),
            (-0.5, 0, 0.25),
            (-0.5, 0, -0.25),
            (-0.25, 1, -0.5),
            (0.25, 1, -0.5),
            (0.5, 1, -0.25),
            (0.5, 1, 0.25),
            (0.25, 1, 0.5),
            (-0.25, 1, 0.5),
            (-0.5, 1, 0.25),
            (-0.5, 1, -0.25)
        )

    @staticmethod
    def get_edges():
        &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
        return (
            (0, 7),
            (0, 1),
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 5),
            (5, 6),
            (6, 7),
            (8, 15),
            (8, 9),
            (9, 10),
            (10, 11),
            (11, 12),
            (12, 13),
            (13, 14),
            (14, 15),
            (0, 8),
            (1, 9),
            (2, 10),
            (3, 11),
            (4, 12),
            (5, 13),
            (6, 14),
            (7, 15)
        )

    @staticmethod
    def get_surfaces():
        &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
        return (
            (9, 8, 11, 10, 12, 15, 8, 11, 13, 12, 15, 14),
            (1, 0, 3, 2, 4, 7, 0, 3, 5, 4, 7, 6),
            (0, 1, 9, 8),
            (1, 2, 10, 9),
            (2, 3, 11, 10),
            (3, 4, 12, 11),
            (4, 5, 13, 12),
            (5, 6, 14, 13),
            (6, 7, 15, 14),
            (7, 15, 8, 0)
        )


class Octahedron(Figure3D):
    &#34;&#34;&#34;A class representing octahedron. It extends Figure3D.&#34;&#34;&#34;

    @staticmethod
    def get_vertices():
        &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
        return (
            (0, 1, 0),
            (-0.5, 0, -0.5),
            (0.5, 0, -0.5),
            (0.5, 0, 0.5),
            (-0.5, 0, 0.5),
            (0, -1, 0)
        )

    @staticmethod
    def get_edges():
        &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
        return (
            (0, 1),
            (0, 2),
            (0, 3),
            (0, 4),
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 1),
            (5, 1),
            (5, 2),
            (5, 3),
            (5, 4)
        )

    @staticmethod
    def get_surfaces():
        &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
        return (
            (0, 1, 2),
            (0, 3, 2),
            (0, 4, 3),
            (0, 4, 1),
            (5, 1, 2),
            (5, 3, 2),
            (5, 4, 3),
            (5, 4, 1)
        )


class Pyramid(Figure3D):
    &#34;&#34;&#34;A class representing pyramid. It extends Figure3D.&#34;&#34;&#34;

    @staticmethod
    def get_vertices():
        &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
        return (
            (0, 1, 0),
            (-1, -1, -1),
            (1, -1, -1),
            (1, -1, 1),
            (-1, -1, 1)
        )

    @staticmethod
    def get_edges():
        &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
        return (
            (0, 1),
            (0, 2),
            (0, 3),
            (0, 4),
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 1)
        )

    @staticmethod
    def get_surfaces():
        &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
        return (
            (0, 1, 2),
            (0, 3, 2),
            (0, 4, 3),
            (0, 4, 1),
            (1, 2, 3, 4)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="memorizeit.figure.Cube"><code class="flex name class">
<span>class <span class="ident">Cube</span></span>
<span>(</span><span>position_z, color, mode, operation)</span>
</code></dt>
<dd>
<section class="desc"><p>A class representing cube. It extends Figure3D.</p>
<p>Initialize 3D figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position_z</code></strong> :&ensp;<code>int</code></dt>
<dd>position of camera Z where figure will be drawn (how far from
beginning - where camera started to move)</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>RGB color code represented as (0-1, 0-1, 0-1) values</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>OpenGL.constant.IntConstant</code></dt>
<dd>mode used to draw figures in 3D - GL_LINES or GL_QUADS</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>function</code></dt>
<dd>method used in specified mode to provide values needed to draw
figure - get_edges or get_surfaces</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L516-L561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Cube(Figure3D):
    &#34;&#34;&#34;A class representing cube. It extends Figure3D.&#34;&#34;&#34;

    @staticmethod
    def get_vertices():
        &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
        return (
            (1, -1, -1),
            (1, 1, -1),
            (-1, 1, -1),
            (-1, -1, -1),
            (1, -1, 1),
            (1, 1, 1),
            (-1, -1, 1),
            (-1, 1, 1)
        )

    @staticmethod
    def get_edges():
        &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
        return (
            (0, 1),
            (0, 3),
            (0, 4),
            (2, 1),
            (2, 3),
            (2, 7),
            (6, 3),
            (6, 4),
            (6, 7),
            (5, 1),
            (5, 4),
            (5, 7)
        )

    @staticmethod
    def get_surfaces():
        &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
        return (
            (0, 1, 2, 3),
            (3, 2, 7, 6),
            (6, 7, 5, 4),
            (4, 5, 1, 0),
            (1, 5, 7, 2),
            (4, 0, 3, 6)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="memorizeit.figure.Cube.get_edges"><code class="name flex">
<span>def <span class="ident">get_edges</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure edges.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L533-L549" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_edges():
    &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
    return (
        (0, 1),
        (0, 3),
        (0, 4),
        (2, 1),
        (2, 3),
        (2, 7),
        (6, 3),
        (6, 4),
        (6, 7),
        (5, 1),
        (5, 4),
        (5, 7)
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Cube.get_surfaces"><code class="name flex">
<span>def <span class="ident">get_surfaces</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure surfaces.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L551-L561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_surfaces():
    &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
    return (
        (0, 1, 2, 3),
        (3, 2, 7, 6),
        (6, 7, 5, 4),
        (4, 5, 1, 0),
        (1, 5, 7, 2),
        (4, 0, 3, 6)
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Cube.get_vertices"><code class="name flex">
<span>def <span class="ident">get_vertices</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure vertices.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L519-L531" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_vertices():
    &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
    return (
        (1, -1, -1),
        (1, 1, -1),
        (-1, 1, -1),
        (-1, -1, -1),
        (1, -1, 1),
        (1, 1, 1),
        (-1, -1, 1),
        (-1, 1, 1)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></b></code>:
<ul class="hlist">
<li><code><a title="memorizeit.figure.Figure3D.adjust_vertices" href="#memorizeit.figure.Figure3D.adjust_vertices">adjust_vertices</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.fire" href="#memorizeit.figure.Figure3D.fire">fire</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.get_random_shift" href="#memorizeit.figure.Figure3D.get_random_shift">get_random_shift</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.normal" href="#memorizeit.figure.Figure3D.normal">normal</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="memorizeit.figure.Figure2D"><code class="flex name class">
<span>class <span class="ident">Figure2D</span></span>
<span>(</span><span>screen, figure, color, mid_point, size)</span>
</code></dt>
<dd>
<section class="desc"><p>A class with methods allowing to display 2D figures on screen.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>screen</code></strong> :&ensp;<code>pygame.Surface</code></dt>
<dd>object representing game screen where created figure will be binded</dd>
<dt><strong><code>figure</code></strong> :&ensp;<code>str</code></dt>
<dd>name of created figure</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> or <code>pygame.Surface</code></dt>
<dd>RGB color code represented as (0-255, 0-255, 0-255) values,
pygame.Surface if photo is used</dd>
<dt><strong><code>points</code></strong> :&ensp;<code>list</code></dt>
<dd>list with points needed to draw figure</dd>
</dl>
<p>Initialize 2D figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>screen</code></strong> :&ensp;<code>pygame.Surface</code></dt>
<dd>object representing game screen where created figure will be binded</dd>
<dt><strong><code>figure</code></strong> :&ensp;<code>str</code></dt>
<dd>name of created figure</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> or <code>pygame.Surface</code></dt>
<dd>RGB color code represented as (0-255, 0-255, 0-255) values,
pygame.Surface if photo is used</dd>
<dt><strong><code>mid_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>center of figure - tuple with two elements - width and height</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size of figure which will be drawn</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L245-L402" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Figure2D:
    &#34;&#34;&#34;
    A class with methods allowing to display 2D figures on screen.

    ...

    Attributes
    ----------
    screen: pygame.Surface
        object representing game screen where created figure will be binded
    figure : str
        name of created figure
    color : tuple or pygame.Surface
        RGB color code represented as (0-255, 0-255, 0-255) values,
        pygame.Surface if photo is used
    points : list
        list with points needed to draw figure
    &#34;&#34;&#34;

    def __init__(self, screen, figure, color, mid_point, size):
        &#34;&#34;&#34;Initialize 2D figure.

        Parameters
        ----------
        screen: pygame.Surface
            object representing game screen where created figure will be binded
        figure : str
            name of created figure
        color : tuple or pygame.Surface
            RGB color code represented as (0-255, 0-255, 0-255) values,
            pygame.Surface if photo is used
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn
        &#34;&#34;&#34;
        self.screen = screen
        self.figure = figure
        self.color = color
        self.points = self.adjust_points(mid_point, size)

    def __repr__(self):
        &#34;&#34;&#34;Return `Figure2D` class representation.&#34;&#34;&#34;
        return f&#39;&lt;{self.figure} with points: {self.points}&gt;&#39;

    def __call__(self):
        &#34;&#34;&#34;Draw figure or displays photo on screen.&#34;&#34;&#34;
        if isinstance(self.color, pygame.Surface):
            self.screen.blit(self.color, self.points)
        else:
            pygame.draw.polygon(self.screen, self.color, self.points)

    def adjust_points(self, mid_point, size):
        &#34;&#34;&#34;Return points needed to display element.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw or display element on screen (each
            has width and height value)
        &#34;&#34;&#34;
        if isinstance(self.color, pygame.Surface):
            w, h = self.color.get_size()
            return [int(mid_point[0] - w / 2), int(mid_point[1] - h / 2)]
        return eval(&#39;self.get_&#39; + self.figure + &#39;_points&#39;)(mid_point, size)

    @staticmethod
    def get_diamond_points(mid_point, size):
        &#34;&#34;&#34;Return points needed to draw diamond.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw diamond on screen (each has width
            and height value)
        &#34;&#34;&#34;
        x, y = mid_point
        s = size
        return [(x, y - s), (x - s, y), (x, y + s), (x + s, y)]

    @staticmethod
    def get_square_points(mid_point, size):
        &#34;&#34;&#34;Return points needed to draw square.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw square on screen (each has width
            and height value)
        &#34;&#34;&#34;
        x, y = mid_point
        s = size
        return [(x - s, y - s), (x - s, y + s), (x + s, y + s), (x + s, y - s)]

    @staticmethod
    def get_triangle_points(mid_point, size):
        &#34;&#34;&#34;Return points needed to draw triangle.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw triangle on screen (each has width
            and height value)
        &#34;&#34;&#34;
        x, y = mid_point
        s = size
        return [(x - s, y + s), (x + s, y + s), (x, y - s)]

    @staticmethod
    def get_octagon_points(mid_point, size):
        &#34;&#34;&#34;Return points needed to draw octagon.

        Parameters
        ----------
        mid_point : tuple
            center of figure - tuple with two elements - width and height
        size : int
            size of figure which will be drawn

        Returns
        -------
        list
            list with points needed to draw octagon on screen (each has width
            and height value)
        &#34;&#34;&#34;
        x, y = mid_point
        s = size
        return [(x - s, y + s / 2), (x - s, y - s / 2), (x - s / 2, y - s),
                (x + s / 2, y - s), (x + s, y - s / 2), (x + s, y + s / 2),
                (x + s / 2, y + s), (x - s / 2, y + s)]</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="memorizeit.figure.Figure2D.get_diamond_points"><code class="name flex">
<span>def <span class="ident">get_diamond_points</span></span>(<span>mid_point, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Return points needed to draw diamond.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mid_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>center of figure - tuple with two elements - width and height</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size of figure which will be drawn</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list with points needed to draw diamond on screen (each has width
and height value)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L318-L337" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_diamond_points(mid_point, size):
    &#34;&#34;&#34;Return points needed to draw diamond.

    Parameters
    ----------
    mid_point : tuple
        center of figure - tuple with two elements - width and height
    size : int
        size of figure which will be drawn

    Returns
    -------
    list
        list with points needed to draw diamond on screen (each has width
        and height value)
    &#34;&#34;&#34;
    x, y = mid_point
    s = size
    return [(x, y - s), (x - s, y), (x, y + s), (x + s, y)]</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Figure2D.get_octagon_points"><code class="name flex">
<span>def <span class="ident">get_octagon_points</span></span>(<span>mid_point, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Return points needed to draw octagon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mid_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>center of figure - tuple with two elements - width and height</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size of figure which will be drawn</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list with points needed to draw octagon on screen (each has width
and height value)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L381-L402" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_octagon_points(mid_point, size):
    &#34;&#34;&#34;Return points needed to draw octagon.

    Parameters
    ----------
    mid_point : tuple
        center of figure - tuple with two elements - width and height
    size : int
        size of figure which will be drawn

    Returns
    -------
    list
        list with points needed to draw octagon on screen (each has width
        and height value)
    &#34;&#34;&#34;
    x, y = mid_point
    s = size
    return [(x - s, y + s / 2), (x - s, y - s / 2), (x - s / 2, y - s),
            (x + s / 2, y - s), (x + s, y - s / 2), (x + s, y + s / 2),
            (x + s / 2, y + s), (x - s / 2, y + s)]</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Figure2D.get_square_points"><code class="name flex">
<span>def <span class="ident">get_square_points</span></span>(<span>mid_point, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Return points needed to draw square.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mid_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>center of figure - tuple with two elements - width and height</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size of figure which will be drawn</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list with points needed to draw square on screen (each has width
and height value)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L339-L358" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_square_points(mid_point, size):
    &#34;&#34;&#34;Return points needed to draw square.

    Parameters
    ----------
    mid_point : tuple
        center of figure - tuple with two elements - width and height
    size : int
        size of figure which will be drawn

    Returns
    -------
    list
        list with points needed to draw square on screen (each has width
        and height value)
    &#34;&#34;&#34;
    x, y = mid_point
    s = size
    return [(x - s, y - s), (x - s, y + s), (x + s, y + s), (x + s, y - s)]</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Figure2D.get_triangle_points"><code class="name flex">
<span>def <span class="ident">get_triangle_points</span></span>(<span>mid_point, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Return points needed to draw triangle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mid_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>center of figure - tuple with two elements - width and height</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size of figure which will be drawn</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list with points needed to draw triangle on screen (each has width
and height value)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L360-L379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_triangle_points(mid_point, size):
    &#34;&#34;&#34;Return points needed to draw triangle.

    Parameters
    ----------
    mid_point : tuple
        center of figure - tuple with two elements - width and height
    size : int
        size of figure which will be drawn

    Returns
    -------
    list
        list with points needed to draw triangle on screen (each has width
        and height value)
    &#34;&#34;&#34;
    x, y = mid_point
    s = size
    return [(x - s, y + s), (x + s, y + s), (x, y - s)]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="memorizeit.figure.Figure2D.adjust_points"><code class="name flex">
<span>def <span class="ident">adjust_points</span></span>(<span>self, mid_point, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Return points needed to display element.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mid_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>center of figure - tuple with two elements - width and height</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size of figure which will be drawn</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list with points needed to draw or display element on screen (each
has width and height value)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L297-L316" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adjust_points(self, mid_point, size):
    &#34;&#34;&#34;Return points needed to display element.

    Parameters
    ----------
    mid_point : tuple
        center of figure - tuple with two elements - width and height
    size : int
        size of figure which will be drawn

    Returns
    -------
    list
        list with points needed to draw or display element on screen (each
        has width and height value)
    &#34;&#34;&#34;
    if isinstance(self.color, pygame.Surface):
        w, h = self.color.get_size()
        return [int(mid_point[0] - w / 2), int(mid_point[1] - h / 2)]
    return eval(&#39;self.get_&#39; + self.figure + &#39;_points&#39;)(mid_point, size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="memorizeit.figure.Figure3D"><code class="flex name class">
<span>class <span class="ident">Figure3D</span></span>
<span>(</span><span>position_z, color, mode, operation)</span>
</code></dt>
<dd>
<section class="desc"><p>A class with methods allowing to display 3D figures on screen.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>RGB color code represented as (0-1, 0-1, 0-1) values</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>OpenGL.constant.IntConstant</code></dt>
<dd>mode used to draw figures in 3D - GL_LINES or GL_QUADS</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>function</code></dt>
<dd>method used in specified mode to provide values needed to draw figure
- get_edges or get_surfaces</dd>
<dt><strong><code>vertices</code></strong> :&ensp;<code>list</code></dt>
<dd>list filled with vertices needed to draw figure</dd>
</dl>
<p>Initialize 3D figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position_z</code></strong> :&ensp;<code>int</code></dt>
<dd>position of camera Z where figure will be drawn (how far from
beginning - where camera started to move)</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>RGB color code represented as (0-1, 0-1, 0-1) values</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>OpenGL.constant.IntConstant</code></dt>
<dd>mode used to draw figures in 3D - GL_LINES or GL_QUADS</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>function</code></dt>
<dd>method used in specified mode to provide values needed to draw
figure - get_edges or get_surfaces</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L405-L513" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Figure3D:
    &#34;&#34;&#34;
    A class with methods allowing to display 3D figures on screen.

    ...

    Attributes
    ----------
    color : tuple
        RGB color code represented as (0-1, 0-1, 0-1) values
    mode : OpenGL.constant.IntConstant
        mode used to draw figures in 3D - GL_LINES or GL_QUADS
    operation : function
        method used in specified mode to provide values needed to draw figure
        - get_edges or get_surfaces
    vertices : list
        list filled with vertices needed to draw figure
    &#34;&#34;&#34;

    def __init__(self, position_z, color, mode, operation):
        &#34;&#34;&#34;Initialize 3D figure.

        Parameters
        ----------
        position_z : int
            position of camera Z where figure will be drawn (how far from
            beginning - where camera started to move)
        color : tuple
            RGB color code represented as (0-1, 0-1, 0-1) values
        mode : OpenGL.constant.IntConstant
            mode used to draw figures in 3D - GL_LINES or GL_QUADS
        operation : function
            method used in specified mode to provide values needed to draw
            figure - get_edges or get_surfaces
        &#34;&#34;&#34;
        self.color = color
        self.mode = mode
        self.operation = operation
        self.vertices = self.adjust_vertices(self.get_random_shift(position_z))

    def __repr__(self):
        &#34;&#34;&#34;Return `Figure3D` class representation.&#34;&#34;&#34;
        return f&#39;&lt;{self.__class__.__name__} with vertices: {self.vertices}&gt;&#39;

    def __call__(self):
        &#34;&#34;&#34;Display figure on screen.&#34;&#34;&#34;
        glBegin(self.mode)
        for element in self.operation():
            for vertex in element:
                color = choice(self.color) if all(
                    [isinstance(x, tuple) for x in self.color]
                ) else self.color
                glColor3fv(color)
                glVertex3fv(self.vertices[vertex])
        glEnd()

    @classmethod
    def normal(cls, position_z, color, *args):
        &#34;&#34;&#34;Set class parameters to draw contour of figure in set color.&#34;&#34;&#34;
        return cls(position_z, color, GL_LINES, cls.get_edges)

    @classmethod
    def fire(cls, position_z, *args):
        &#34;&#34;&#34;Set class parameters to draws full figure imitating flame.&#34;&#34;&#34;
        return cls(position_z, ((0.5, 0, 0), (1, 0.5, 0)),
                   GL_QUADS, cls.get_surfaces)

    @staticmethod
    def get_random_shift(position_z):
        &#34;&#34;&#34;Return adjusted point according to moving camera.

        Parameters
        ----------
        position_z : int
            position of camera Z where figure will be drawn (how far from
            beginning - where camera started to move)

        Returns
        -------
        tuple
            containing x, y, z randomized values for point where figure will
            be drawn
        &#34;&#34;&#34;
        x = choice((-1, 1)) * randrange(2, 10)
        y = choice((-1, 1)) * randrange(2, 10)
        z = randrange(int(position_z - 90), int(position_z - 60))
        return x, y, z

    def adjust_vertices(self, point):
        &#34;&#34;&#34;Return adjusted figure vertices according to set point.

        Parameters
        ----------
        point : tuple
            tuple with x, y, z value - position where figure will be drawn

        Returns
        -------
        list
            containing new vertices values allowing to draw 3D figure
        &#34;&#34;&#34;
        new_vertices = []
        for vertice in self.get_vertices():
            new = []
            new.append(vertice[0] + point[0])
            new.append(vertice[1] + point[1])
            new.append(vertice[2] + point[2])
            new_vertices.append(new)
        return new_vertices</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="memorizeit.figure.Cube" href="#memorizeit.figure.Cube">Cube</a></li>
<li><a title="memorizeit.figure.Octagon" href="#memorizeit.figure.Octagon">Octagon</a></li>
<li><a title="memorizeit.figure.Octahedron" href="#memorizeit.figure.Octahedron">Octahedron</a></li>
<li><a title="memorizeit.figure.Pyramid" href="#memorizeit.figure.Pyramid">Pyramid</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="memorizeit.figure.Figure3D.fire"><code class="name flex">
<span>def <span class="ident">fire</span></span>(<span>position_z, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Set class parameters to draws full figure imitating flame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L466-L470" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def fire(cls, position_z, *args):
    &#34;&#34;&#34;Set class parameters to draws full figure imitating flame.&#34;&#34;&#34;
    return cls(position_z, ((0.5, 0, 0), (1, 0.5, 0)),
               GL_QUADS, cls.get_surfaces)</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Figure3D.get_random_shift"><code class="name flex">
<span>def <span class="ident">get_random_shift</span></span>(<span>position_z)</span>
</code></dt>
<dd>
<section class="desc"><p>Return adjusted point according to moving camera.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position_z</code></strong> :&ensp;<code>int</code></dt>
<dd>position of camera Z where figure will be drawn (how far from
beginning - where camera started to move)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>containing x, y, z randomized values for point where figure will
be drawn</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L472-L491" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_random_shift(position_z):
    &#34;&#34;&#34;Return adjusted point according to moving camera.

    Parameters
    ----------
    position_z : int
        position of camera Z where figure will be drawn (how far from
        beginning - where camera started to move)

    Returns
    -------
    tuple
        containing x, y, z randomized values for point where figure will
        be drawn
    &#34;&#34;&#34;
    x = choice((-1, 1)) * randrange(2, 10)
    y = choice((-1, 1)) * randrange(2, 10)
    z = randrange(int(position_z - 90), int(position_z - 60))
    return x, y, z</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Figure3D.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>position_z, color, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Set class parameters to draw contour of figure in set color.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L461-L464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def normal(cls, position_z, color, *args):
    &#34;&#34;&#34;Set class parameters to draw contour of figure in set color.&#34;&#34;&#34;
    return cls(position_z, color, GL_LINES, cls.get_edges)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="memorizeit.figure.Figure3D.adjust_vertices"><code class="name flex">
<span>def <span class="ident">adjust_vertices</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<section class="desc"><p>Return adjusted figure vertices according to set point.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>tuple with x, y, z value - position where figure will be drawn</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>containing new vertices values allowing to draw 3D figure</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L493-L513" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adjust_vertices(self, point):
    &#34;&#34;&#34;Return adjusted figure vertices according to set point.

    Parameters
    ----------
    point : tuple
        tuple with x, y, z value - position where figure will be drawn

    Returns
    -------
    list
        containing new vertices values allowing to draw 3D figure
    &#34;&#34;&#34;
    new_vertices = []
    for vertice in self.get_vertices():
        new = []
        new.append(vertice[0] + point[0])
        new.append(vertice[1] + point[1])
        new.append(vertice[2] + point[2])
        new_vertices.append(new)
    return new_vertices</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="memorizeit.figure.Octagon"><code class="flex name class">
<span>class <span class="ident">Octagon</span></span>
<span>(</span><span>position_z, color, mode, operation)</span>
</code></dt>
<dd>
<section class="desc"><p>A class representing octagon. It extends Figure3D.</p>
<p>Initialize 3D figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position_z</code></strong> :&ensp;<code>int</code></dt>
<dd>position of camera Z where figure will be drawn (how far from
beginning - where camera started to move)</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>RGB color code represented as (0-1, 0-1, 0-1) values</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>OpenGL.constant.IntConstant</code></dt>
<dd>mode used to draw figures in 3D - GL_LINES or GL_QUADS</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>function</code></dt>
<dd>method used in specified mode to provide values needed to draw
figure - get_edges or get_surfaces</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L564-L633" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Octagon(Figure3D):
    &#34;&#34;&#34;A class representing octagon. It extends Figure3D.&#34;&#34;&#34;

    @staticmethod
    def get_vertices():
        &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
        return (
            (-0.25, 0, -0.5),
            (0.25, 0, -0.5),
            (0.5, 0, -0.25),
            (0.5, 0, 0.25),
            (0.25, 0, 0.5),
            (-0.25, 0, 0.5),
            (-0.5, 0, 0.25),
            (-0.5, 0, -0.25),
            (-0.25, 1, -0.5),
            (0.25, 1, -0.5),
            (0.5, 1, -0.25),
            (0.5, 1, 0.25),
            (0.25, 1, 0.5),
            (-0.25, 1, 0.5),
            (-0.5, 1, 0.25),
            (-0.5, 1, -0.25)
        )

    @staticmethod
    def get_edges():
        &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
        return (
            (0, 7),
            (0, 1),
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 5),
            (5, 6),
            (6, 7),
            (8, 15),
            (8, 9),
            (9, 10),
            (10, 11),
            (11, 12),
            (12, 13),
            (13, 14),
            (14, 15),
            (0, 8),
            (1, 9),
            (2, 10),
            (3, 11),
            (4, 12),
            (5, 13),
            (6, 14),
            (7, 15)
        )

    @staticmethod
    def get_surfaces():
        &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
        return (
            (9, 8, 11, 10, 12, 15, 8, 11, 13, 12, 15, 14),
            (1, 0, 3, 2, 4, 7, 0, 3, 5, 4, 7, 6),
            (0, 1, 9, 8),
            (1, 2, 10, 9),
            (2, 3, 11, 10),
            (3, 4, 12, 11),
            (4, 5, 13, 12),
            (5, 6, 14, 13),
            (6, 7, 15, 14),
            (7, 15, 8, 0)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="memorizeit.figure.Octagon.get_edges"><code class="name flex">
<span>def <span class="ident">get_edges</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure edges.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L589-L617" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_edges():
    &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
    return (
        (0, 7),
        (0, 1),
        (1, 2),
        (2, 3),
        (3, 4),
        (4, 5),
        (5, 6),
        (6, 7),
        (8, 15),
        (8, 9),
        (9, 10),
        (10, 11),
        (11, 12),
        (12, 13),
        (13, 14),
        (14, 15),
        (0, 8),
        (1, 9),
        (2, 10),
        (3, 11),
        (4, 12),
        (5, 13),
        (6, 14),
        (7, 15)
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Octagon.get_surfaces"><code class="name flex">
<span>def <span class="ident">get_surfaces</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure surfaces.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L619-L633" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_surfaces():
    &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
    return (
        (9, 8, 11, 10, 12, 15, 8, 11, 13, 12, 15, 14),
        (1, 0, 3, 2, 4, 7, 0, 3, 5, 4, 7, 6),
        (0, 1, 9, 8),
        (1, 2, 10, 9),
        (2, 3, 11, 10),
        (3, 4, 12, 11),
        (4, 5, 13, 12),
        (5, 6, 14, 13),
        (6, 7, 15, 14),
        (7, 15, 8, 0)
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Octagon.get_vertices"><code class="name flex">
<span>def <span class="ident">get_vertices</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure vertices.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L567-L587" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_vertices():
    &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
    return (
        (-0.25, 0, -0.5),
        (0.25, 0, -0.5),
        (0.5, 0, -0.25),
        (0.5, 0, 0.25),
        (0.25, 0, 0.5),
        (-0.25, 0, 0.5),
        (-0.5, 0, 0.25),
        (-0.5, 0, -0.25),
        (-0.25, 1, -0.5),
        (0.25, 1, -0.5),
        (0.5, 1, -0.25),
        (0.5, 1, 0.25),
        (0.25, 1, 0.5),
        (-0.25, 1, 0.5),
        (-0.5, 1, 0.25),
        (-0.5, 1, -0.25)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></b></code>:
<ul class="hlist">
<li><code><a title="memorizeit.figure.Figure3D.adjust_vertices" href="#memorizeit.figure.Figure3D.adjust_vertices">adjust_vertices</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.fire" href="#memorizeit.figure.Figure3D.fire">fire</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.get_random_shift" href="#memorizeit.figure.Figure3D.get_random_shift">get_random_shift</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.normal" href="#memorizeit.figure.Figure3D.normal">normal</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="memorizeit.figure.Octahedron"><code class="flex name class">
<span>class <span class="ident">Octahedron</span></span>
<span>(</span><span>position_z, color, mode, operation)</span>
</code></dt>
<dd>
<section class="desc"><p>A class representing octahedron. It extends Figure3D.</p>
<p>Initialize 3D figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position_z</code></strong> :&ensp;<code>int</code></dt>
<dd>position of camera Z where figure will be drawn (how far from
beginning - where camera started to move)</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>RGB color code represented as (0-1, 0-1, 0-1) values</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>OpenGL.constant.IntConstant</code></dt>
<dd>mode used to draw figures in 3D - GL_LINES or GL_QUADS</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>function</code></dt>
<dd>method used in specified mode to provide values needed to draw
figure - get_edges or get_surfaces</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L636-L681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Octahedron(Figure3D):
    &#34;&#34;&#34;A class representing octahedron. It extends Figure3D.&#34;&#34;&#34;

    @staticmethod
    def get_vertices():
        &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
        return (
            (0, 1, 0),
            (-0.5, 0, -0.5),
            (0.5, 0, -0.5),
            (0.5, 0, 0.5),
            (-0.5, 0, 0.5),
            (0, -1, 0)
        )

    @staticmethod
    def get_edges():
        &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
        return (
            (0, 1),
            (0, 2),
            (0, 3),
            (0, 4),
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 1),
            (5, 1),
            (5, 2),
            (5, 3),
            (5, 4)
        )

    @staticmethod
    def get_surfaces():
        &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
        return (
            (0, 1, 2),
            (0, 3, 2),
            (0, 4, 3),
            (0, 4, 1),
            (5, 1, 2),
            (5, 3, 2),
            (5, 4, 3),
            (5, 4, 1)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="memorizeit.figure.Octahedron.get_edges"><code class="name flex">
<span>def <span class="ident">get_edges</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure edges.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L651-L667" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_edges():
    &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
    return (
        (0, 1),
        (0, 2),
        (0, 3),
        (0, 4),
        (1, 2),
        (2, 3),
        (3, 4),
        (4, 1),
        (5, 1),
        (5, 2),
        (5, 3),
        (5, 4)
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Octahedron.get_surfaces"><code class="name flex">
<span>def <span class="ident">get_surfaces</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure surfaces.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L669-L681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_surfaces():
    &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
    return (
        (0, 1, 2),
        (0, 3, 2),
        (0, 4, 3),
        (0, 4, 1),
        (5, 1, 2),
        (5, 3, 2),
        (5, 4, 3),
        (5, 4, 1)
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Octahedron.get_vertices"><code class="name flex">
<span>def <span class="ident">get_vertices</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure vertices.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L639-L649" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_vertices():
    &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
    return (
        (0, 1, 0),
        (-0.5, 0, -0.5),
        (0.5, 0, -0.5),
        (0.5, 0, 0.5),
        (-0.5, 0, 0.5),
        (0, -1, 0)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></b></code>:
<ul class="hlist">
<li><code><a title="memorizeit.figure.Figure3D.adjust_vertices" href="#memorizeit.figure.Figure3D.adjust_vertices">adjust_vertices</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.fire" href="#memorizeit.figure.Figure3D.fire">fire</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.get_random_shift" href="#memorizeit.figure.Figure3D.get_random_shift">get_random_shift</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.normal" href="#memorizeit.figure.Figure3D.normal">normal</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="memorizeit.figure.Pyramid"><code class="flex name class">
<span>class <span class="ident">Pyramid</span></span>
<span>(</span><span>position_z, color, mode, operation)</span>
</code></dt>
<dd>
<section class="desc"><p>A class representing pyramid. It extends Figure3D.</p>
<p>Initialize 3D figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position_z</code></strong> :&ensp;<code>int</code></dt>
<dd>position of camera Z where figure will be drawn (how far from
beginning - where camera started to move)</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>RGB color code represented as (0-1, 0-1, 0-1) values</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>OpenGL.constant.IntConstant</code></dt>
<dd>mode used to draw figures in 3D - GL_LINES or GL_QUADS</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>function</code></dt>
<dd>method used in specified mode to provide values needed to draw
figure - get_edges or get_surfaces</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L684-L721" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Pyramid(Figure3D):
    &#34;&#34;&#34;A class representing pyramid. It extends Figure3D.&#34;&#34;&#34;

    @staticmethod
    def get_vertices():
        &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
        return (
            (0, 1, 0),
            (-1, -1, -1),
            (1, -1, -1),
            (1, -1, 1),
            (-1, -1, 1)
        )

    @staticmethod
    def get_edges():
        &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
        return (
            (0, 1),
            (0, 2),
            (0, 3),
            (0, 4),
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 1)
        )

    @staticmethod
    def get_surfaces():
        &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
        return (
            (0, 1, 2),
            (0, 3, 2),
            (0, 4, 3),
            (0, 4, 1),
            (1, 2, 3, 4)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="memorizeit.figure.Pyramid.get_edges"><code class="name flex">
<span>def <span class="ident">get_edges</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure edges.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L698-L710" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_edges():
    &#34;&#34;&#34;Return figure edges.&#34;&#34;&#34;
    return (
        (0, 1),
        (0, 2),
        (0, 3),
        (0, 4),
        (1, 2),
        (2, 3),
        (3, 4),
        (4, 1)
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Pyramid.get_surfaces"><code class="name flex">
<span>def <span class="ident">get_surfaces</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure surfaces.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L712-L721" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_surfaces():
    &#34;&#34;&#34;Return figure surfaces.&#34;&#34;&#34;
    return (
        (0, 1, 2),
        (0, 3, 2),
        (0, 4, 3),
        (0, 4, 1),
        (1, 2, 3, 4)
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Pyramid.get_vertices"><code class="name flex">
<span>def <span class="ident">get_vertices</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return figure vertices.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L687-L696" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_vertices():
    &#34;&#34;&#34;Return figure vertices.&#34;&#34;&#34;
    return (
        (0, 1, 0),
        (-1, -1, -1),
        (1, -1, -1),
        (1, -1, 1),
        (-1, -1, 1)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></b></code>:
<ul class="hlist">
<li><code><a title="memorizeit.figure.Figure3D.adjust_vertices" href="#memorizeit.figure.Figure3D.adjust_vertices">adjust_vertices</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.fire" href="#memorizeit.figure.Figure3D.fire">fire</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.get_random_shift" href="#memorizeit.figure.Figure3D.get_random_shift">get_random_shift</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.normal" href="#memorizeit.figure.Figure3D.normal">normal</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="memorizeit.figure.Wave"><code class="flex name class">
<span>class <span class="ident">Wave</span></span>
<span>(</span><span>figure_type, color, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>A class with collection of the same methods both for Wave2D and Wave3D.</p>
<p>It is base, responsible for creating wave of elements, iterating through
its objects, counting and calling them (drawing).</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>figure_type</code></strong> :&ensp;<code>str</code></dt>
<dd>name of figures which will be in the wave</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> or <code>pygame.Surface</code> or <code>False</code></dt>
<dd>RGB code of color for wave (0-1, 0-1, 0-1), False if each element in
wave will have his own color or pygame.Surface in case if photo will
be used as displayed element</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>rest of parameters needed to create specified type of wave, see Wave2D
and Wave3D</dd>
</dl>
<p>Initialize wave.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figure_type</code></strong> :&ensp;<code>str</code></dt>
<dd>name of figures which will be in the wave</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> or <code>pygame.Surface</code> or <code>False</code></dt>
<dd>RGB code of color for wave (0-1, 0-1, 0-1), False if each element
in wave will have his own color or pygame.Surface in case if photo
will be used as displayed element</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>rest of parameters needed to create specified type of wave, see
Wave2D and Wave3D</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L26-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Wave:
    &#34;&#34;&#34;
    A class with collection of the same methods both for Wave2D and Wave3D.

    It is base, responsible for creating wave of elements, iterating through
    its objects, counting and calling them (drawing).

    ...

    Attributes
    ----------
    figure_type : str
        name of figures which will be in the wave
    color : tuple or pygame.Surface or False
        RGB code of color for wave (0-1, 0-1, 0-1), False if each element in
        wave will have his own color or pygame.Surface in case if photo will
        be used as displayed element
    *args
        rest of parameters needed to create specified type of wave, see Wave2D
        and Wave3D
    &#34;&#34;&#34;

    def __init__(self, figure_type, color, *args):
        &#34;&#34;&#34;Initialize wave.

        Parameters
        ----------
        figure_type : str
            name of figures which will be in the wave
        color : tuple or pygame.Surface or False
            RGB code of color for wave (0-1, 0-1, 0-1), False if each element
            in wave will have his own color or pygame.Surface in case if photo
            will be used as displayed element
        *args
            rest of parameters needed to create specified type of wave, see
            Wave2D and Wave3D
        &#34;&#34;&#34;
        self.figure = figure_type
        self.figures = []
        self.fill(color, *args)

    def __repr__(self):
        &#34;&#34;&#34;Return `Wave` class representation.&#34;&#34;&#34;
        name = self.__class__.__name__
        return f&#39;&lt;{name} of {self.__len__()} {self.figure.lower()}s&gt;&#39;

    def __iter__(self):
        &#34;&#34;&#34;Iterate through wave figures.&#34;&#34;&#34;
        return (x for x in self.figures)

    def __len__(self):
        &#34;&#34;&#34;Return number of wave figures.&#34;&#34;&#34;
        return len(self.figures)

    def __call__(self):
        &#34;&#34;&#34;Spawn (display) wave on screen.&#34;&#34;&#34;
        for figure in self:
            figure()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="memorizeit.figure.Wave2D" href="#memorizeit.figure.Wave2D">Wave2D</a></li>
<li><a title="memorizeit.figure.Wave3D" href="#memorizeit.figure.Wave3D">Wave3D</a></li>
</ul>
</dd>
<dt id="memorizeit.figure.Wave2D"><code class="flex name class">
<span>class <span class="ident">Wave2D</span></span>
<span>(</span><span>figure_type, color, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>A class with methods needed to display 2D wave.</p>
<p>It is responsible for calculating proper points on screen to display
objects, setting their size, pick amount. Has description how 2D wave
should be created. It is child of class Wave.</p>
<p>&hellip;</p>
<h2 id="methods">Methods</h2>
<p>get_amount()
randomly pick number of elements from 1 to 9 according to their weights
get_mid_points(resolution)
according to resolution of screen - tuple (width, height) divides
screen into nine equal fields (net 3x3) and return list with their
middle points (width, height)
get_figure_size(resolution)
according to resolution of screen - tuple (width, height) return
integer with size of figure
fill(color, screen, resolution)
populates figures list with 2D figures objects binded to screen
(<code>pygame.Surface</code>). Use wave color or photo if it is passed else pick
random color for each element. Resolution is used to set figure size
and region of screen where it will be displayed</p>
<p>Initialize wave.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figure_type</code></strong> :&ensp;<code>str</code></dt>
<dd>name of figures which will be in the wave</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> or <code>pygame.Surface</code> or <code>False</code></dt>
<dd>RGB code of color for wave (0-1, 0-1, 0-1), False if each element
in wave will have his own color or pygame.Surface in case if photo
will be used as displayed element</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>rest of parameters needed to create specified type of wave, see
Wave2D and Wave3D</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L86-L195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Wave2D(Wave):
    &#34;&#34;&#34;
    A class with methods needed to display 2D wave.

    It is responsible for calculating proper points on screen to display
    objects, setting their size, pick amount. Has description how 2D wave
    should be created. It is child of class Wave.

    ...

    Methods
    -------
    get_amount()
        randomly pick number of elements from 1 to 9 according to their weights
    get_mid_points(resolution)
        according to resolution of screen - tuple (width, height) divides
        screen into nine equal fields (net 3x3) and return list with their
        middle points (width, height)
    get_figure_size(resolution)
        according to resolution of screen - tuple (width, height) return
        integer with size of figure
    fill(color, screen, resolution)
        populates figures list with 2D figures objects binded to screen
        (`pygame.Surface`). Use wave color or photo if it is passed else pick
        random color for each element. Resolution is used to set figure size
        and region of screen where it will be displayed
    &#34;&#34;&#34;

    @staticmethod
    def get_amount():
        &#34;&#34;&#34;Pick random number of elements from 1 to 9 according to weights.&#34;&#34;&#34;
        return choices(
            range(1, 10),
            weights=[0.03, 0.1, 0.2, 0.2, 0.2, 0.15, 0.1, 0.01, 0.01]
        )[0]

    @staticmethod
    def get_mid_points(resolution):
        &#34;&#34;&#34;Divide screen in net 3x3 and return middle point of each field.

        Parameters
        ----------
        resolution : tuple
            a tuple with two int values - width, height - according to
            resolution of used monitor

        Returns
        -------
        list
            a list with 9 positions (screen divided in net 3x3) - middle point
            of each part of divided screen
        &#34;&#34;&#34;
        w, h = resolution
        return [(int(x), int(y))
                for x in (w / 6, w / 2, w - w / 6)
                for y in (h / 6, h / 2, h - h / 6)]

    @staticmethod
    def get_figure_size(resolution):
        &#34;&#34;&#34;Return size of figure (used in drawing).

        Parameters
        ----------
        resolution : tuple
            a tuple with two int values - width, height - according to
            resolution of used monitor

        Returns
        -------
        int
            size of figure which will be drawn
        &#34;&#34;&#34;
        w, h = resolution
        return int(min(w / 3, h / 3) / 4)

    def fill(self, color, screen, resolution):
        &#34;&#34;&#34;Populate figures list.

        2D figures objects are created and binded to screen
        (`pygame.Surface`). It uses wave color (RGB code (0-1, 0-1, 0-1) which
        is converted to (0-255, 0-255, 0-255)) or photo if it is passed else
        it picks random color for each element. Resolution is used to set
        figure size and region of screen where it will be displayed. Amount of
        elements in wave is picked randomly according to method get_amount().

        Parameters
        ----------
        color : tuple or pygame.Surface or False
            RGB color code represented as (0-1, 0-1, 0-1) values,
            pygame.Surface if each object will display photo or False in case
            when we don&#39;t want to create wave in solid color, but use random
            color for each object
        screen: pygame.Surface
            object representing game screen where created figures will be
            binded
        resolution : tuple
            a tuple with two int values - width, height - according to
            resolution of used monitor
        &#34;&#34;&#34;
        for point in sample(
                self.get_mid_points(resolution), self.get_amount()):
            figure_color = color if color else colors.Random().get_color()

            if not isinstance(color, pygame.Surface):
                figure_color = colors.convert(figure_color)

            self.figures.append(
                Figure2D(screen, self.figure, figure_color, point,
                         self.get_figure_size(resolution))
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="memorizeit.figure.Wave" href="#memorizeit.figure.Wave">Wave</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="memorizeit.figure.Wave2D.get_amount"><code class="name flex">
<span>def <span class="ident">get_amount</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Pick random number of elements from 1 to 9 according to weights.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L114-L120" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_amount():
    &#34;&#34;&#34;Pick random number of elements from 1 to 9 according to weights.&#34;&#34;&#34;
    return choices(
        range(1, 10),
        weights=[0.03, 0.1, 0.2, 0.2, 0.2, 0.15, 0.1, 0.01, 0.01]
    )[0]</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Wave2D.get_figure_size"><code class="name flex">
<span>def <span class="ident">get_figure_size</span></span>(<span>resolution)</span>
</code></dt>
<dd>
<section class="desc"><p>Return size of figure (used in drawing).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with two int values - width, height - according to
resolution of used monitor</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>size of figure which will be drawn</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L143-L159" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_figure_size(resolution):
    &#34;&#34;&#34;Return size of figure (used in drawing).

    Parameters
    ----------
    resolution : tuple
        a tuple with two int values - width, height - according to
        resolution of used monitor

    Returns
    -------
    int
        size of figure which will be drawn
    &#34;&#34;&#34;
    w, h = resolution
    return int(min(w / 3, h / 3) / 4)</code></pre>
</details>
</dd>
<dt id="memorizeit.figure.Wave2D.get_mid_points"><code class="name flex">
<span>def <span class="ident">get_mid_points</span></span>(<span>resolution)</span>
</code></dt>
<dd>
<section class="desc"><p>Divide screen in net 3x3 and return middle point of each field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with two int values - width, height - according to
resolution of used monitor</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>a list with 9 positions (screen divided in net 3x3) - middle point
of each part of divided screen</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L122-L141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_mid_points(resolution):
    &#34;&#34;&#34;Divide screen in net 3x3 and return middle point of each field.

    Parameters
    ----------
    resolution : tuple
        a tuple with two int values - width, height - according to
        resolution of used monitor

    Returns
    -------
    list
        a list with 9 positions (screen divided in net 3x3) - middle point
        of each part of divided screen
    &#34;&#34;&#34;
    w, h = resolution
    return [(int(x), int(y))
            for x in (w / 6, w / 2, w - w / 6)
            for y in (h / 6, h / 2, h - h / 6)]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="memorizeit.figure.Wave2D.fill"><code class="name flex">
<span>def <span class="ident">fill</span></span>(<span>self, color, screen, resolution)</span>
</code></dt>
<dd>
<section class="desc"><p>Populate figures list.</p>
<p>2D figures objects are created and binded to screen
(<code>pygame.Surface</code>). It uses wave color (RGB code (0-1, 0-1, 0-1) which
is converted to (0-255, 0-255, 0-255)) or photo if it is passed else
it picks random color for each element. Resolution is used to set
figure size and region of screen where it will be displayed. Amount of
elements in wave is picked randomly according to method get_amount().</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> or <code>pygame.Surface</code> or <code>False</code></dt>
<dd>RGB color code represented as (0-1, 0-1, 0-1) values,
pygame.Surface if each object will display photo or False in case
when we don't want to create wave in solid color, but use random
color for each object</dd>
<dt><strong><code>screen</code></strong> :&ensp;<code>pygame.Surface</code></dt>
<dd>object representing game screen where created figures will be
binded</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with two int values - width, height - according to
resolution of used monitor</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L161-L195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fill(self, color, screen, resolution):
    &#34;&#34;&#34;Populate figures list.

    2D figures objects are created and binded to screen
    (`pygame.Surface`). It uses wave color (RGB code (0-1, 0-1, 0-1) which
    is converted to (0-255, 0-255, 0-255)) or photo if it is passed else
    it picks random color for each element. Resolution is used to set
    figure size and region of screen where it will be displayed. Amount of
    elements in wave is picked randomly according to method get_amount().

    Parameters
    ----------
    color : tuple or pygame.Surface or False
        RGB color code represented as (0-1, 0-1, 0-1) values,
        pygame.Surface if each object will display photo or False in case
        when we don&#39;t want to create wave in solid color, but use random
        color for each object
    screen: pygame.Surface
        object representing game screen where created figures will be
        binded
    resolution : tuple
        a tuple with two int values - width, height - according to
        resolution of used monitor
    &#34;&#34;&#34;
    for point in sample(
            self.get_mid_points(resolution), self.get_amount()):
        figure_color = color if color else colors.Random().get_color()

        if not isinstance(color, pygame.Surface):
            figure_color = colors.convert(figure_color)

        self.figures.append(
            Figure2D(screen, self.figure, figure_color, point,
                     self.get_figure_size(resolution))
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="memorizeit.figure.Wave3D"><code class="flex name class">
<span>class <span class="ident">Wave3D</span></span>
<span>(</span><span>figure_type, color, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>A class with method allowing to create 3D wave.</p>
<p>It fills figure list with proper objects. It is child of class Wave.</p>
<p>&hellip;</p>
<h2 id="methods">Methods</h2>
<p>fill(color, position)
populates figures list with 3D figures objects. Position Z of camera
must be specified (how far from beginning figure will be drawn). It
uses wave color if it is passed else picks random color for each
element.</p>
<p>Initialize wave.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figure_type</code></strong> :&ensp;<code>str</code></dt>
<dd>name of figures which will be in the wave</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> or <code>pygame.Surface</code> or <code>False</code></dt>
<dd>RGB code of color for wave (0-1, 0-1, 0-1), False if each element
in wave will have his own color or pygame.Surface in case if photo
will be used as displayed element</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>rest of parameters needed to create specified type of wave, see
Wave2D and Wave3D</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L198-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Wave3D(Wave):
    &#34;&#34;&#34;
    A class with method allowing to create 3D wave.

    It fills figure list with proper objects. It is child of class Wave.

    ...

    Methods
    -------
    fill(color, position)
        populates figures list with 3D figures objects. Position Z of camera
        must be specified (how far from beginning figure will be drawn). It
        uses wave color if it is passed else picks random color for each
        element.
    &#34;&#34;&#34;

    def fill(self, color, position_z):
        &#34;&#34;&#34;Populate figures list.

        3D figures objects are created according to randomly generated number
        in range 2-6. It uses wave color (RGB code (0-1, 0-1, 0-1) if it is
        passed else it picks random color for each element. Figures are
        created in normal mode. Easter egg (for those who like to read
        documentation as I do): there is also available fire mode (see
        Figure3D fire @classmethod) which will simulate flames. Be aware that
        each object will be colored same way. Replace `.normal` with `.fire`
        in loop below - where objects are created.

        Parameters
        ----------
        color : tuple or False
            RGB color code represented as (0-1, 0-1, 0-1) or False in case
            when we don&#39;t want to create wave in solid color, but use random
            color for each object
        position_z : int
            position of camera Z where figure will be drawn (how far from
            beginning - where camera started to move)
        &#34;&#34;&#34;
        for _ in range(randint(2, 6)):
            figure_color = color if color else colors.Random().get_color()

            self.figures.append(
                eval(self.figure).normal(position_z, figure_color)
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="memorizeit.figure.Wave" href="#memorizeit.figure.Wave">Wave</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="memorizeit.figure.Wave3D.fill"><code class="name flex">
<span>def <span class="ident">fill</span></span>(<span>self, color, position_z)</span>
</code></dt>
<dd>
<section class="desc"><p>Populate figures list.</p>
<p>3D figures objects are created according to randomly generated number
in range 2-6. It uses wave color (RGB code (0-1, 0-1, 0-1) if it is
passed else it picks random color for each element. Figures are
created in normal mode. Easter egg (for those who like to read
documentation as I do): there is also available fire mode (see
Figure3D fire @classmethod) which will simulate flames. Be aware that
each object will be colored same way. Replace <code>.normal</code> with <code>.fire</code>
in loop below - where objects are created.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> or <code>False</code></dt>
<dd>RGB color code represented as (0-1, 0-1, 0-1) or False in case
when we don't want to create wave in solid color, but use random
color for each object</dd>
<dt><strong><code>position_z</code></strong> :&ensp;<code>int</code></dt>
<dd>position of camera Z where figure will be drawn (how far from
beginning - where camera started to move)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/figure.py#L215-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fill(self, color, position_z):
    &#34;&#34;&#34;Populate figures list.

    3D figures objects are created according to randomly generated number
    in range 2-6. It uses wave color (RGB code (0-1, 0-1, 0-1) if it is
    passed else it picks random color for each element. Figures are
    created in normal mode. Easter egg (for those who like to read
    documentation as I do): there is also available fire mode (see
    Figure3D fire @classmethod) which will simulate flames. Be aware that
    each object will be colored same way. Replace `.normal` with `.fire`
    in loop below - where objects are created.

    Parameters
    ----------
    color : tuple or False
        RGB color code represented as (0-1, 0-1, 0-1) or False in case
        when we don&#39;t want to create wave in solid color, but use random
        color for each object
    position_z : int
        position of camera Z where figure will be drawn (how far from
        beginning - where camera started to move)
    &#34;&#34;&#34;
    for _ in range(randint(2, 6)):
        figure_color = color if color else colors.Random().get_color()

        self.figures.append(
            eval(self.figure).normal(position_z, figure_color)
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header><img src="https://raw.githubusercontent.com/ethru/memorizeit/master/img/brain.png" alt=""></header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#figure">Figure</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="memorizeit" href="index.html">memorizeit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="memorizeit.figure.Cube" href="#memorizeit.figure.Cube">Cube</a></code></h4>
<ul class="">
<li><code><a title="memorizeit.figure.Cube.get_edges" href="#memorizeit.figure.Cube.get_edges">get_edges</a></code></li>
<li><code><a title="memorizeit.figure.Cube.get_surfaces" href="#memorizeit.figure.Cube.get_surfaces">get_surfaces</a></code></li>
<li><code><a title="memorizeit.figure.Cube.get_vertices" href="#memorizeit.figure.Cube.get_vertices">get_vertices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.figure.Figure2D" href="#memorizeit.figure.Figure2D">Figure2D</a></code></h4>
<ul class="">
<li><code><a title="memorizeit.figure.Figure2D.adjust_points" href="#memorizeit.figure.Figure2D.adjust_points">adjust_points</a></code></li>
<li><code><a title="memorizeit.figure.Figure2D.get_diamond_points" href="#memorizeit.figure.Figure2D.get_diamond_points">get_diamond_points</a></code></li>
<li><code><a title="memorizeit.figure.Figure2D.get_octagon_points" href="#memorizeit.figure.Figure2D.get_octagon_points">get_octagon_points</a></code></li>
<li><code><a title="memorizeit.figure.Figure2D.get_square_points" href="#memorizeit.figure.Figure2D.get_square_points">get_square_points</a></code></li>
<li><code><a title="memorizeit.figure.Figure2D.get_triangle_points" href="#memorizeit.figure.Figure2D.get_triangle_points">get_triangle_points</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.figure.Figure3D" href="#memorizeit.figure.Figure3D">Figure3D</a></code></h4>
<ul class="">
<li><code><a title="memorizeit.figure.Figure3D.adjust_vertices" href="#memorizeit.figure.Figure3D.adjust_vertices">adjust_vertices</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.fire" href="#memorizeit.figure.Figure3D.fire">fire</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.get_random_shift" href="#memorizeit.figure.Figure3D.get_random_shift">get_random_shift</a></code></li>
<li><code><a title="memorizeit.figure.Figure3D.normal" href="#memorizeit.figure.Figure3D.normal">normal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.figure.Octagon" href="#memorizeit.figure.Octagon">Octagon</a></code></h4>
<ul class="">
<li><code><a title="memorizeit.figure.Octagon.get_edges" href="#memorizeit.figure.Octagon.get_edges">get_edges</a></code></li>
<li><code><a title="memorizeit.figure.Octagon.get_surfaces" href="#memorizeit.figure.Octagon.get_surfaces">get_surfaces</a></code></li>
<li><code><a title="memorizeit.figure.Octagon.get_vertices" href="#memorizeit.figure.Octagon.get_vertices">get_vertices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.figure.Octahedron" href="#memorizeit.figure.Octahedron">Octahedron</a></code></h4>
<ul class="">
<li><code><a title="memorizeit.figure.Octahedron.get_edges" href="#memorizeit.figure.Octahedron.get_edges">get_edges</a></code></li>
<li><code><a title="memorizeit.figure.Octahedron.get_surfaces" href="#memorizeit.figure.Octahedron.get_surfaces">get_surfaces</a></code></li>
<li><code><a title="memorizeit.figure.Octahedron.get_vertices" href="#memorizeit.figure.Octahedron.get_vertices">get_vertices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.figure.Pyramid" href="#memorizeit.figure.Pyramid">Pyramid</a></code></h4>
<ul class="">
<li><code><a title="memorizeit.figure.Pyramid.get_edges" href="#memorizeit.figure.Pyramid.get_edges">get_edges</a></code></li>
<li><code><a title="memorizeit.figure.Pyramid.get_surfaces" href="#memorizeit.figure.Pyramid.get_surfaces">get_surfaces</a></code></li>
<li><code><a title="memorizeit.figure.Pyramid.get_vertices" href="#memorizeit.figure.Pyramid.get_vertices">get_vertices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.figure.Wave" href="#memorizeit.figure.Wave">Wave</a></code></h4>
</li>
<li>
<h4><code><a title="memorizeit.figure.Wave2D" href="#memorizeit.figure.Wave2D">Wave2D</a></code></h4>
<ul class="">
<li><code><a title="memorizeit.figure.Wave2D.fill" href="#memorizeit.figure.Wave2D.fill">fill</a></code></li>
<li><code><a title="memorizeit.figure.Wave2D.get_amount" href="#memorizeit.figure.Wave2D.get_amount">get_amount</a></code></li>
<li><code><a title="memorizeit.figure.Wave2D.get_figure_size" href="#memorizeit.figure.Wave2D.get_figure_size">get_figure_size</a></code></li>
<li><code><a title="memorizeit.figure.Wave2D.get_mid_points" href="#memorizeit.figure.Wave2D.get_mid_points">get_mid_points</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.figure.Wave3D" href="#memorizeit.figure.Wave3D">Wave3D</a></code></h4>
<ul class="">
<li><code><a title="memorizeit.figure.Wave3D.fill" href="#memorizeit.figure.Wave3D.fill">fill</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>