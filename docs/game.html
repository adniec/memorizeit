<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>memorizeit.game API documentation</title>
<meta name="description" content="Game â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>memorizeit.game</code></h1>
</header>
<section id="section-intro">
<h4 id="game">Game</h4>
<p>This module contains classes responsible for launching game in preferred mode
- static (2D) or dynamic (3D). It set appropriate environment for game based
on <code>pygame</code> or <code>OpenGL</code>. It cover methods which pick proper elements, count
them, adjust speed and time of a game. Modules used: <code>OpenGL</code>, <code>pathlib</code>,
<code>PIL</code>, <code>pygame</code>, <code>random</code>, <code>sys</code>, <code>time</code>.</p>
<p>License:
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L0-L381" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;#### Game

This module contains classes responsible for launching game in preferred mode
- static (2D) or dynamic (3D). It set appropriate environment for game based
on `pygame` or `OpenGL`. It cover methods which pick proper elements, count
them, adjust speed and time of a game. Modules used: `OpenGL`, `pathlib`,
`PIL`, `pygame`, `random`, `sys`, `time`.

License:
THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
&#34;&#34;&#34;

from pathlib import Path
from random import sample, choice
from sys import platform
from time import time

import OpenGL.GL as gl
from OpenGL.GLU import gluPerspective
from PIL import Image
import pygame
from pygame.locals import DOUBLEBUF, OPENGL

from memorizeit.figure import Wave3D, Wave2D
from memorizeit import gui
from memorizeit import colors
from memorizeit import config


class Game:
    &#34;&#34;&#34;
    Run game.

    A class with collection of the same methods needed both in Dynamic and
    Static class. It is base, responsible for processing game, adjusting its
    settings and launching summarization afterwards.

    ...

    Attributes
    ----------
    resolution : tuple
        a tuple with two int values - width, height - according to resolution
        of used monitor
    settings : dict
        dictionary with loaded from file settings which will be used in a game
    timer : dict
        dictionary with information about beginning of a game, its length,
        single and last wave time
    colors : colors.Random
        object responsible for generating random color codes in RGB (0-1, 0-1,
        0-1) format
    elements : dict
        dictionary filled with names of elements used in game and corresponding
         them color
    counter : dictionary
        dictionary containing names of elements and their occurrence in game
    wave : figure.Wave2D or figure.Wave3D
        object responsible for creating wave of elements on the screen
    &#34;&#34;&#34;

    def __init__(self, resolution):
        &#34;&#34;&#34;Initialize steps to process game.

        Parameters
        ----------
        resolution : tuple
            a tuple with two int values - width, height - according to
            resolution of used monitor
        &#34;&#34;&#34;
        self.resolution = resolution
        pygame.mouse.set_visible(False)
        self.settings = config.Config().get_settings()
        self.timer = self.create_timer()
        self.color = colors.Random()
        self.elements = self.set_elements()
        self.counter = {x: 0 for x in list(self.elements)}
        self.wave = None
        self.prepare_environment()
        config.Handler(self.run_game, self.has_time_left)()
        pygame.mouse.set_visible(True)
        gui.Summary(self.counter)

    def has_time_left(self):
        &#34;&#34;&#34;Check if game is still running.&#34;&#34;&#34;
        return self.timer[&#39;total&#39;] &gt; time() - self.timer[&#39;start&#39;]

    def create_timer(self):
        &#34;&#34;&#34;Create dictionary with information about game time.

        It contains beginning of a game, length, single and last wave time.
        &#34;&#34;&#34;
        total = self.settings[&#39;time&#39;]
        wave = 7 / self.settings[&#39;speed&#39;]
        return {
            &#39;start&#39;: time(),
            &#39;total&#39;: total,
            &#39;wave&#39;: wave * 2,
            &#39;last&#39;: total - wave
        }

    def play_sound(self):
        &#34;&#34;&#34;Play sound if setting is turned on.&#34;&#34;&#34;
        if self.settings[&#39;sound&#39;] == &#39;On&#39;:
            try:
                path = Path(__file__).parent.absolute() / &#39;sound.ogg&#39;
                pygame.mixer.init()
                pygame.mixer.Sound(str(path)).play()
            except (pygame.error, FileNotFoundError):
                pass

    def adjust_elements(self, figures, amount):
        &#34;&#34;&#34;Set elements used in game.

        Parameters
        ----------
        figures : list
            a list with figures names from which will be picked figures taking
            part in a game
        amount : int
            number of elements taking part in a game - loaded from settings

        Returns
        -------
        dict
            dictionary with randomly picked elements and corresponding them
            color according to color difficulty setting
        &#34;&#34;&#34;
        picked = sample(figures, amount)
        color = colors.pick(self.settings[&#39;colors&#39;], amount)
        if type(color) is bool:
            color = [color] * amount
        return {figure: color[index] for index, figure in enumerate(picked)}

    def pick_element(self):
        &#34;&#34;&#34;Return one randomly picked element with its color.

        Based on game difficulty color can be random for each wave or figure.
        &#34;&#34;&#34;
        figure = choice(list(self.elements))
        color = self.elements[figure]
        if not isinstance(color, (pygame.Surface, tuple)):
            color = self.color.get_color() if color else False
        return figure, color

    def create_wave(self, function, *args):
        &#34;&#34;&#34;Create wave of randomly picked element.

        Picks figure, creates from it wave which will be displayed on screen.
        It updates counter and play sound if it is set to on. Function says
        which type of wave will be created - 2D or 3D. *args passed depends on
        this type.

        Parameters
        ----------
        function : Wave2D or Wave3D
            used to create proper wave object depending on launched game mode
        *args
            values needed to create specified Wave type - 2D (screen,
            resolution) or 3D (z_position). To see more check documentation for
            proper Wave class in module figure

        Returns
        -------
        figure.Wave2D or figure.Wave3D
            object with created wave, used to display it - 2D or 3D type
            according to passed function
        &#34;&#34;&#34;
        figure = self.pick_element()
        wave = function(*figure, *args)
        self.counter[figure[0]] = self.counter[figure[0]] + len(wave)
        self.play_sound()
        return wave

    def is_wave_finished(self, condition):
        &#34;&#34;&#34;Specify if displayed wave should be replaced with new one.&#34;&#34;&#34;
        if condition:
            if self.timer[&#39;last&#39;] &gt; time() - self.timer[&#39;start&#39;]:
                return True
        return False


class Static(Game):
    &#34;&#34;&#34;
    Setup static game.

    A class containing methods used in static game mode. Sets environment for
    binding 2D figures or images to game screen represented by
    `pygame.Surface`. It extend `Game` class.

    ...

    Attributes
    ----------
    screen: pygame.Surface
        object representing game screen where created 2D figures or images
        will be binded
    &#34;&#34;&#34;

    def prepare_environment(self):
        &#34;&#34;&#34;Set basics needed to launch 2D game mode.

        Specify attribute used only in static game mode - screen. Extend
        attribute timer by interval allowing to control spawning new 2D waves
        on screen.
        &#34;&#34;&#34;
        self.screen = pygame.display.set_mode(
            self.resolution,
            pygame.FULLSCREEN
        )
        self.timer[&#39;interval&#39;] = self.timer[&#39;start&#39;]
        self.wave = self.create_wave(Wave2D, self.screen, self.resolution)

    def run_game(self):
        &#34;&#34;&#34;Spawn waves of 2D figures based on time interval.&#34;&#34;&#34;
        if self.is_wave_finished(
                time() &gt; self.timer[&#39;interval&#39;] + self.timer[&#39;wave&#39;]
        ):
            self.timer[&#39;interval&#39;] += self.timer[&#39;wave&#39;]
            self.spawn_new_wave()
        else:
            self.wave()

    def spawn_new_wave(self):
        &#34;&#34;&#34;Clear screen and spawn new wave of figures or images.&#34;&#34;&#34;
        self.screen.fill((0, 0, 0))
        self.wave = self.create_wave(Wave2D, self.screen, self.resolution)

    def get_images(self):
        &#34;&#34;&#34;Load images from their directory (&#39;memorizeit/img/elements/&#39;).

        Returns
        -------
        dict
            dictionary with image name and its representation as
            `pygame.Surface`
        &#34;&#34;&#34;
        images = {}
        try:
            path = Path(__file__).parent.absolute() / &#39;img&#39; / &#39;elements&#39;
            for image in path.iterdir():
                images[image.stem] = self.load_image(image)
        except OSError:
            pass
        return images

    def load_image(self, path):
        &#34;&#34;&#34;Load image from set path and scale it.

        Parameters
        ----------
        path : pathlib.Path
            location of image to load

        Returns
        -------
        pygame.Surface
            information about loaded and scaled image represented as
            `pygame.Surface`
        &#34;&#34;&#34;
        image = Image.open(path)
        image = self.fit_image(image)
        return pygame.image.fromstring(image.tobytes(), image.size, image.mode)

    def fit_image(self, image):
        &#34;&#34;&#34;Scale image.

        Lower width or height of image as long as it will fit dedicated place
        on screen (calculated from monitor resolution).

        Parameters
        ----------
        image : PIL.Image
            image representation from PIL library

        Returns
        -------
        PIL.Image
            scaled image represented by PIL
        &#34;&#34;&#34;
        x, y = [x / 5 for x in self.resolution]
        w, h = image.size
        ratio = x / w if x &lt; w else y / h if y &lt; h else False
        if ratio:
            size = [int(x * ratio) for x in image.size]
            image = image.resize(size, Image.ANTIALIAS)
            return self.fit_image(image)
        return image

    def set_elements(self):
        &#34;&#34;&#34;Return elements used in game.

        It contain list of allowed elements in game. At first load images from
        their directory then fill missing elements by drawing 2D figures
        picked from elements list according to game settings (amount).
        Returned elements are gathered in dictionary with their names and
        color code or image.
        &#34;&#34;&#34;
        amount = self.settings[&#39;figures&#39;]
        images = self.get_images()
        if len(images) &lt; amount:
            figures = self.adjust_elements(
                [&#39;square&#39;, &#39;triangle&#39;, &#39;octagon&#39;, &#39;diamond&#39;],
                amount - len(images)
            )
            return {**images, **figures}
        else:
            picked = sample(list(images), amount)
            return {x: images[x] for x in picked}


class Dynamic(Game):
    &#34;&#34;&#34;
    Setup dynamic game.

    A class containing methods used in dynamic game mode. Sets environment for
    creating 3D figures and moves camera during gameplay. It extend `Game`
    class.

    ...

    Attributes
    ----------
    spawned_at : int
        camera Z value (how far from beginning it moved) - needed to create
        figures and make them visible
    &#34;&#34;&#34;

    def prepare_environment(self):
        &#34;&#34;&#34;Set basics needed to launch 3D game mode.&#34;&#34;&#34;
        pygame.display.set_mode(
            self.resolution,
            DOUBLEBUF | OPENGL | pygame.FULLSCREEN
        )
        gluPerspective(45, (self.resolution[0] / self.resolution[1]), 0.1, 50)
        self.spawned_at = -10
        self.wave = self.create_wave(Wave3D, self.spawned_at)

    def run_game(self):
        &#34;&#34;&#34;Spawn waves of 3D figures based on length of camera Z movement.&#34;&#34;&#34;
        camera_z = self.move_view()
        if self.is_wave_finished(camera_z &lt; self.spawned_at - 100):
            self.spawn_new_wave(camera_z)
        else:
            self.wave()

    def spawn_new_wave(self, z_position):
        &#34;&#34;&#34;Remove old wave and spawn new one according to position of camera.

        Parameters
        ----------
        z_position : int
            value of camera Z - where it is moved
        &#34;&#34;&#34;
        del self.wave
        self.wave = self.create_wave(Wave3D, z_position)
        self.spawned_at = z_position

    def move_view(self):
        &#34;&#34;&#34;Responsible for camera movement, return z position.&#34;&#34;&#34;
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        gl.glTranslatef(0, 0, self.get_speed())
        camera_z = gl.glGetDoublev(gl.GL_MODELVIEW_MATRIX)[3][2]
        return int(camera_z)

    def get_speed(self):
        &#34;&#34;&#34;According to used platform adjust speed for moving camera.&#34;&#34;&#34;
        s = self.settings[&#39;speed&#39;]
        return s / 5 - 0.15 * s if &#39;win&#39; in platform else s / 5

    def set_elements(self):
        &#34;&#34;&#34;From allowed figures return those which are picked to game.&#34;&#34;&#34;
        return self.adjust_elements(
            [&#39;Cube&#39;, &#39;Pyramid&#39;, &#39;Octahedron&#39;, &#39;Octagon&#39;],
            self.settings[&#39;figures&#39;]
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="memorizeit.game.Dynamic"><code class="flex name class">
<span>class <span class="ident">Dynamic</span></span>
<span>(</span><span>resolution)</span>
</code></dt>
<dd>
<section class="desc"><p>Setup dynamic game.</p>
<p>A class containing methods used in dynamic game mode. Sets environment for
creating 3D figures and moves camera during gameplay. It extend <code><a title="memorizeit.game.Game" href="#memorizeit.game.Game">Game</a></code>
class.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>spawned_at</code></strong> :&ensp;<code>int</code></dt>
<dd>camera Z value (how far from beginning it moved) - needed to create
figures and make them visible</dd>
</dl>
<p>Initialize steps to process game.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with two int values - width, height - according to
resolution of used monitor</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L318-L382" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Dynamic(Game):
    &#34;&#34;&#34;
    Setup dynamic game.

    A class containing methods used in dynamic game mode. Sets environment for
    creating 3D figures and moves camera during gameplay. It extend `Game`
    class.

    ...

    Attributes
    ----------
    spawned_at : int
        camera Z value (how far from beginning it moved) - needed to create
        figures and make them visible
    &#34;&#34;&#34;

    def prepare_environment(self):
        &#34;&#34;&#34;Set basics needed to launch 3D game mode.&#34;&#34;&#34;
        pygame.display.set_mode(
            self.resolution,
            DOUBLEBUF | OPENGL | pygame.FULLSCREEN
        )
        gluPerspective(45, (self.resolution[0] / self.resolution[1]), 0.1, 50)
        self.spawned_at = -10
        self.wave = self.create_wave(Wave3D, self.spawned_at)

    def run_game(self):
        &#34;&#34;&#34;Spawn waves of 3D figures based on length of camera Z movement.&#34;&#34;&#34;
        camera_z = self.move_view()
        if self.is_wave_finished(camera_z &lt; self.spawned_at - 100):
            self.spawn_new_wave(camera_z)
        else:
            self.wave()

    def spawn_new_wave(self, z_position):
        &#34;&#34;&#34;Remove old wave and spawn new one according to position of camera.

        Parameters
        ----------
        z_position : int
            value of camera Z - where it is moved
        &#34;&#34;&#34;
        del self.wave
        self.wave = self.create_wave(Wave3D, z_position)
        self.spawned_at = z_position

    def move_view(self):
        &#34;&#34;&#34;Responsible for camera movement, return z position.&#34;&#34;&#34;
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        gl.glTranslatef(0, 0, self.get_speed())
        camera_z = gl.glGetDoublev(gl.GL_MODELVIEW_MATRIX)[3][2]
        return int(camera_z)

    def get_speed(self):
        &#34;&#34;&#34;According to used platform adjust speed for moving camera.&#34;&#34;&#34;
        s = self.settings[&#39;speed&#39;]
        return s / 5 - 0.15 * s if &#39;win&#39; in platform else s / 5

    def set_elements(self):
        &#34;&#34;&#34;From allowed figures return those which are picked to game.&#34;&#34;&#34;
        return self.adjust_elements(
            [&#39;Cube&#39;, &#39;Pyramid&#39;, &#39;Octahedron&#39;, &#39;Octagon&#39;],
            self.settings[&#39;figures&#39;]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="memorizeit.game.Game" href="#memorizeit.game.Game">Game</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="memorizeit.game.Dynamic.get_speed"><code class="name flex">
<span>def <span class="ident">get_speed</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>According to used platform adjust speed for moving camera.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L372-L375" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_speed(self):
    &#34;&#34;&#34;According to used platform adjust speed for moving camera.&#34;&#34;&#34;
    s = self.settings[&#39;speed&#39;]
    return s / 5 - 0.15 * s if &#39;win&#39; in platform else s / 5</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Dynamic.move_view"><code class="name flex">
<span>def <span class="ident">move_view</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Responsible for camera movement, return z position.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L365-L370" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def move_view(self):
    &#34;&#34;&#34;Responsible for camera movement, return z position.&#34;&#34;&#34;
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
    gl.glTranslatef(0, 0, self.get_speed())
    camera_z = gl.glGetDoublev(gl.GL_MODELVIEW_MATRIX)[3][2]
    return int(camera_z)</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Dynamic.prepare_environment"><code class="name flex">
<span>def <span class="ident">prepare_environment</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Set basics needed to launch 3D game mode.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L335-L343" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def prepare_environment(self):
    &#34;&#34;&#34;Set basics needed to launch 3D game mode.&#34;&#34;&#34;
    pygame.display.set_mode(
        self.resolution,
        DOUBLEBUF | OPENGL | pygame.FULLSCREEN
    )
    gluPerspective(45, (self.resolution[0] / self.resolution[1]), 0.1, 50)
    self.spawned_at = -10
    self.wave = self.create_wave(Wave3D, self.spawned_at)</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Dynamic.run_game"><code class="name flex">
<span>def <span class="ident">run_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Spawn waves of 3D figures based on length of camera Z movement.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L345-L351" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_game(self):
    &#34;&#34;&#34;Spawn waves of 3D figures based on length of camera Z movement.&#34;&#34;&#34;
    camera_z = self.move_view()
    if self.is_wave_finished(camera_z &lt; self.spawned_at - 100):
        self.spawn_new_wave(camera_z)
    else:
        self.wave()</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Dynamic.set_elements"><code class="name flex">
<span>def <span class="ident">set_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>From allowed figures return those which are picked to game.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L377-L382" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_elements(self):
    &#34;&#34;&#34;From allowed figures return those which are picked to game.&#34;&#34;&#34;
    return self.adjust_elements(
        [&#39;Cube&#39;, &#39;Pyramid&#39;, &#39;Octahedron&#39;, &#39;Octagon&#39;],
        self.settings[&#39;figures&#39;]
    )</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Dynamic.spawn_new_wave"><code class="name flex">
<span>def <span class="ident">spawn_new_wave</span></span>(<span>self, z_position)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove old wave and spawn new one according to position of camera.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z_position</code></strong> :&ensp;<code>int</code></dt>
<dd>value of camera Z - where it is moved</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L353-L363" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def spawn_new_wave(self, z_position):
    &#34;&#34;&#34;Remove old wave and spawn new one according to position of camera.

    Parameters
    ----------
    z_position : int
        value of camera Z - where it is moved
    &#34;&#34;&#34;
    del self.wave
    self.wave = self.create_wave(Wave3D, z_position)
    self.spawned_at = z_position</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="memorizeit.game.Game" href="#memorizeit.game.Game">Game</a></b></code>:
<ul class="hlist">
<li><code><a title="memorizeit.game.Game.adjust_elements" href="#memorizeit.game.Game.adjust_elements">adjust_elements</a></code></li>
<li><code><a title="memorizeit.game.Game.create_timer" href="#memorizeit.game.Game.create_timer">create_timer</a></code></li>
<li><code><a title="memorizeit.game.Game.create_wave" href="#memorizeit.game.Game.create_wave">create_wave</a></code></li>
<li><code><a title="memorizeit.game.Game.has_time_left" href="#memorizeit.game.Game.has_time_left">has_time_left</a></code></li>
<li><code><a title="memorizeit.game.Game.is_wave_finished" href="#memorizeit.game.Game.is_wave_finished">is_wave_finished</a></code></li>
<li><code><a title="memorizeit.game.Game.pick_element" href="#memorizeit.game.Game.pick_element">pick_element</a></code></li>
<li><code><a title="memorizeit.game.Game.play_sound" href="#memorizeit.game.Game.play_sound">play_sound</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="memorizeit.game.Game"><code class="flex name class">
<span>class <span class="ident">Game</span></span>
<span>(</span><span>resolution)</span>
</code></dt>
<dd>
<section class="desc"><p>Run game.</p>
<p>A class with collection of the same methods needed both in Dynamic and
Static class. It is base, responsible for processing game, adjusting its
settings and launching summarization afterwards.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with two int values - width, height - according to resolution
of used monitor</dd>
<dt><strong><code>settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with loaded from file settings which will be used in a game</dd>
<dt><strong><code>timer</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with information about beginning of a game, its length,
single and last wave time</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>colors.Random</code></dt>
<dd>object responsible for generating random color codes in RGB (0-1, 0-1,
0-1) format</dd>
<dt><strong><code>elements</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary filled with names of elements used in game and corresponding
them color</dd>
<dt><strong><code>counter</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>dictionary containing names of elements and their occurrence in game</dd>
<dt><strong><code>wave</code></strong> :&ensp;<code>figure.Wave2D</code> or <code>figure.Wave3D</code></dt>
<dd>object responsible for creating wave of elements on the screen</dd>
</dl>
<p>Initialize steps to process game.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with two int values - width, height - according to
resolution of used monitor</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L36-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Game:
    &#34;&#34;&#34;
    Run game.

    A class with collection of the same methods needed both in Dynamic and
    Static class. It is base, responsible for processing game, adjusting its
    settings and launching summarization afterwards.

    ...

    Attributes
    ----------
    resolution : tuple
        a tuple with two int values - width, height - according to resolution
        of used monitor
    settings : dict
        dictionary with loaded from file settings which will be used in a game
    timer : dict
        dictionary with information about beginning of a game, its length,
        single and last wave time
    colors : colors.Random
        object responsible for generating random color codes in RGB (0-1, 0-1,
        0-1) format
    elements : dict
        dictionary filled with names of elements used in game and corresponding
         them color
    counter : dictionary
        dictionary containing names of elements and their occurrence in game
    wave : figure.Wave2D or figure.Wave3D
        object responsible for creating wave of elements on the screen
    &#34;&#34;&#34;

    def __init__(self, resolution):
        &#34;&#34;&#34;Initialize steps to process game.

        Parameters
        ----------
        resolution : tuple
            a tuple with two int values - width, height - according to
            resolution of used monitor
        &#34;&#34;&#34;
        self.resolution = resolution
        pygame.mouse.set_visible(False)
        self.settings = config.Config().get_settings()
        self.timer = self.create_timer()
        self.color = colors.Random()
        self.elements = self.set_elements()
        self.counter = {x: 0 for x in list(self.elements)}
        self.wave = None
        self.prepare_environment()
        config.Handler(self.run_game, self.has_time_left)()
        pygame.mouse.set_visible(True)
        # gui.Summary(self.counter)

    def has_time_left(self):
        &#34;&#34;&#34;Check if game is still running.&#34;&#34;&#34;
        return self.timer[&#39;total&#39;] &gt; time() - self.timer[&#39;start&#39;]

    def create_timer(self):
        &#34;&#34;&#34;Create dictionary with information about game time.

        It contains beginning of a game, length, single and last wave time.
        &#34;&#34;&#34;
        total = self.settings[&#39;time&#39;]
        wave = 7 / self.settings[&#39;speed&#39;]
        return {
            &#39;start&#39;: time(),
            &#39;total&#39;: total,
            &#39;wave&#39;: wave * 2,
            &#39;last&#39;: total - wave
        }

    def play_sound(self):
        &#34;&#34;&#34;Play sound if setting is turned on.&#34;&#34;&#34;
        if self.settings[&#39;sound&#39;] == &#39;On&#39;:
            try:
                path = Path(__file__).parent.absolute() / &#39;sound.ogg&#39;
                pygame.mixer.init()
                pygame.mixer.Sound(str(path)).play()
            except (pygame.error, FileNotFoundError):
                pass

    def adjust_elements(self, figures, amount):
        &#34;&#34;&#34;Set elements used in game.

        Parameters
        ----------
        figures : list
            a list with figures names from which will be picked figures taking
            part in a game
        amount : int
            number of elements taking part in a game - loaded from settings

        Returns
        -------
        dict
            dictionary with randomly picked elements and corresponding them
            color according to color difficulty setting
        &#34;&#34;&#34;
        picked = sample(figures, amount)
        color = colors.pick(self.settings[&#39;colors&#39;], amount)
        if type(color) is bool:
            color = [color] * amount
        return {figure: color[index] for index, figure in enumerate(picked)}

    def pick_element(self):
        &#34;&#34;&#34;Return one randomly picked element with its color.

        Based on game difficulty color can be random for each wave or figure.
        &#34;&#34;&#34;
        figure = choice(list(self.elements))
        color = self.elements[figure]
        if not isinstance(color, (pygame.Surface, tuple)):
            color = self.color.get_color() if color else False
        return figure, color

    def create_wave(self, function, *args):
        &#34;&#34;&#34;Create wave of randomly picked element.

        Picks figure, creates from it wave which will be displayed on screen.
        It updates counter and play sound if it is set to on. Function says
        which type of wave will be created - 2D or 3D. *args passed depends on
        this type.

        Parameters
        ----------
        function : Wave2D or Wave3D
            used to create proper wave object depending on launched game mode
        *args
            values needed to create specified Wave type - 2D (screen,
            resolution) or 3D (z_position). To see more check documentation for
            proper Wave class in module figure

        Returns
        -------
        figure.Wave2D or figure.Wave3D
            object with created wave, used to display it - 2D or 3D type
            according to passed function
        &#34;&#34;&#34;
        figure = self.pick_element()
        wave = function(*figure, *args)
        self.counter[figure[0]] = self.counter[figure[0]] + len(wave)
        self.play_sound()
        return wave

    def is_wave_finished(self, condition):
        &#34;&#34;&#34;Specify if displayed wave should be replaced with new one.&#34;&#34;&#34;
        if condition:
            if self.timer[&#39;last&#39;] &gt; time() - self.timer[&#39;start&#39;]:
                return True
        return False</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="memorizeit.game.Dynamic" href="#memorizeit.game.Dynamic">Dynamic</a></li>
<li><a title="memorizeit.game.Static" href="#memorizeit.game.Static">Static</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="memorizeit.game.Game.adjust_elements"><code class="name flex">
<span>def <span class="ident">adjust_elements</span></span>(<span>self, figures, amount)</span>
</code></dt>
<dd>
<section class="desc"><p>Set elements used in game.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figures</code></strong> :&ensp;<code>list</code></dt>
<dd>a list with figures names from which will be picked figures taking
part in a game</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>number of elements taking part in a game - loaded from settings</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dictionary with randomly picked elements and corresponding them
color according to color difficulty setting</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L118-L139" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adjust_elements(self, figures, amount):
    &#34;&#34;&#34;Set elements used in game.

    Parameters
    ----------
    figures : list
        a list with figures names from which will be picked figures taking
        part in a game
    amount : int
        number of elements taking part in a game - loaded from settings

    Returns
    -------
    dict
        dictionary with randomly picked elements and corresponding them
        color according to color difficulty setting
    &#34;&#34;&#34;
    picked = sample(figures, amount)
    color = colors.pick(self.settings[&#39;colors&#39;], amount)
    if type(color) is bool:
        color = [color] * amount
    return {figure: color[index] for index, figure in enumerate(picked)}</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Game.create_timer"><code class="name flex">
<span>def <span class="ident">create_timer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Create dictionary with information about game time.</p>
<p>It contains beginning of a game, length, single and last wave time.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L94-L106" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_timer(self):
    &#34;&#34;&#34;Create dictionary with information about game time.

    It contains beginning of a game, length, single and last wave time.
    &#34;&#34;&#34;
    total = self.settings[&#39;time&#39;]
    wave = 7 / self.settings[&#39;speed&#39;]
    return {
        &#39;start&#39;: time(),
        &#39;total&#39;: total,
        &#39;wave&#39;: wave * 2,
        &#39;last&#39;: total - wave
    }</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Game.create_wave"><code class="name flex">
<span>def <span class="ident">create_wave</span></span>(<span>self, function, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Create wave of randomly picked element.</p>
<p>Picks figure, creates from it wave which will be displayed on screen.
It updates counter and play sound if it is set to on. Function says
which type of wave will be created - 2D or 3D. *args passed depends on
this type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Wave2D</code> or <code>Wave3D</code></dt>
<dd>used to create proper wave object depending on launched game mode</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>values needed to create specified Wave type - 2D (screen,
resolution) or 3D (z_position). To see more check documentation for
proper Wave class in module figure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>figure.Wave2D</code> or <code>figure.Wave3D</code></dt>
<dd>object with created wave, used to display it - 2D or 3D type
according to passed function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L152-L179" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_wave(self, function, *args):
    &#34;&#34;&#34;Create wave of randomly picked element.

    Picks figure, creates from it wave which will be displayed on screen.
    It updates counter and play sound if it is set to on. Function says
    which type of wave will be created - 2D or 3D. *args passed depends on
    this type.

    Parameters
    ----------
    function : Wave2D or Wave3D
        used to create proper wave object depending on launched game mode
    *args
        values needed to create specified Wave type - 2D (screen,
        resolution) or 3D (z_position). To see more check documentation for
        proper Wave class in module figure

    Returns
    -------
    figure.Wave2D or figure.Wave3D
        object with created wave, used to display it - 2D or 3D type
        according to passed function
    &#34;&#34;&#34;
    figure = self.pick_element()
    wave = function(*figure, *args)
    self.counter[figure[0]] = self.counter[figure[0]] + len(wave)
    self.play_sound()
    return wave</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Game.has_time_left"><code class="name flex">
<span>def <span class="ident">has_time_left</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if game is still running.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L90-L92" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_time_left(self):
    &#34;&#34;&#34;Check if game is still running.&#34;&#34;&#34;
    return self.timer[&#39;total&#39;] &gt; time() - self.timer[&#39;start&#39;]</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Game.is_wave_finished"><code class="name flex">
<span>def <span class="ident">is_wave_finished</span></span>(<span>self, condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Specify if displayed wave should be replaced with new one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L181-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_wave_finished(self, condition):
    &#34;&#34;&#34;Specify if displayed wave should be replaced with new one.&#34;&#34;&#34;
    if condition:
        if self.timer[&#39;last&#39;] &gt; time() - self.timer[&#39;start&#39;]:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Game.pick_element"><code class="name flex">
<span>def <span class="ident">pick_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return one randomly picked element with its color.</p>
<p>Based on game difficulty color can be random for each wave or figure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L141-L150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pick_element(self):
    &#34;&#34;&#34;Return one randomly picked element with its color.

    Based on game difficulty color can be random for each wave or figure.
    &#34;&#34;&#34;
    figure = choice(list(self.elements))
    color = self.elements[figure]
    if not isinstance(color, (pygame.Surface, tuple)):
        color = self.color.get_color() if color else False
    return figure, color</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Game.play_sound"><code class="name flex">
<span>def <span class="ident">play_sound</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Play sound if setting is turned on.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L108-L116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def play_sound(self):
    &#34;&#34;&#34;Play sound if setting is turned on.&#34;&#34;&#34;
    if self.settings[&#39;sound&#39;] == &#39;On&#39;:
        try:
            path = Path(__file__).parent.absolute() / &#39;sound.ogg&#39;
            pygame.mixer.init()
            pygame.mixer.Sound(str(path)).play()
        except (pygame.error, FileNotFoundError):
            pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="memorizeit.game.Static"><code class="flex name class">
<span>class <span class="ident">Static</span></span>
<span>(</span><span>resolution)</span>
</code></dt>
<dd>
<section class="desc"><p>Setup static game.</p>
<p>A class containing methods used in static game mode. Sets environment for
binding 2D figures or images to game screen represented by
<code>pygame.Surface</code>. It extend <code><a title="memorizeit.game.Game" href="#memorizeit.game.Game">Game</a></code> class.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>screen</code></strong> :&ensp;<code>pygame.Surface</code></dt>
<dd>object representing game screen where created 2D figures or images
will be binded</dd>
</dl>
<p>Initialize steps to process game.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with two int values - width, height - according to
resolution of used monitor</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L189-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Static(Game):
    &#34;&#34;&#34;
    Setup static game.

    A class containing methods used in static game mode. Sets environment for
    binding 2D figures or images to game screen represented by
    `pygame.Surface`. It extend `Game` class.

    ...

    Attributes
    ----------
    screen: pygame.Surface
        object representing game screen where created 2D figures or images
        will be binded
    &#34;&#34;&#34;

    def prepare_environment(self):
        &#34;&#34;&#34;Set basics needed to launch 2D game mode.

        Specify attribute used only in static game mode - screen. Extend
        attribute timer by interval allowing to control spawning new 2D waves
        on screen.
        &#34;&#34;&#34;
        self.screen = pygame.display.set_mode(
            self.resolution,
            pygame.FULLSCREEN
        )
        self.timer[&#39;interval&#39;] = self.timer[&#39;start&#39;]
        self.wave = self.create_wave(Wave2D, self.screen, self.resolution)

    def run_game(self):
        &#34;&#34;&#34;Spawn waves of 2D figures based on time interval.&#34;&#34;&#34;
        if self.is_wave_finished(
                time() &gt; self.timer[&#39;interval&#39;] + self.timer[&#39;wave&#39;]
        ):
            self.timer[&#39;interval&#39;] += self.timer[&#39;wave&#39;]
            self.spawn_new_wave()
        else:
            self.wave()

    def spawn_new_wave(self):
        &#34;&#34;&#34;Clear screen and spawn new wave of figures or images.&#34;&#34;&#34;
        self.screen.fill((0, 0, 0))
        self.wave = self.create_wave(Wave2D, self.screen, self.resolution)

    def get_images(self):
        &#34;&#34;&#34;Load images from their directory (&#39;memorizeit/img/elements/&#39;).

        Returns
        -------
        dict
            dictionary with image name and its representation as
            `pygame.Surface`
        &#34;&#34;&#34;
        images = {}
        try:
            path = Path(__file__).parent.absolute() / &#39;img&#39; / &#39;elements&#39;
            for image in path.iterdir():
                images[image.stem] = self.load_image(image)
        except OSError:
            pass
        return images

    def load_image(self, path):
        &#34;&#34;&#34;Load image from set path and scale it.

        Parameters
        ----------
        path : pathlib.Path
            location of image to load

        Returns
        -------
        pygame.Surface
            information about loaded and scaled image represented as
            `pygame.Surface`
        &#34;&#34;&#34;
        image = Image.open(path)
        image = self.fit_image(image)
        return pygame.image.fromstring(image.tobytes(), image.size, image.mode)

    def fit_image(self, image):
        &#34;&#34;&#34;Scale image.

        Lower width or height of image as long as it will fit dedicated place
        on screen (calculated from monitor resolution).

        Parameters
        ----------
        image : PIL.Image
            image representation from PIL library

        Returns
        -------
        PIL.Image
            scaled image represented by PIL
        &#34;&#34;&#34;
        x, y = [x / 5 for x in self.resolution]
        w, h = image.size
        ratio = x / w if x &lt; w else y / h if y &lt; h else False
        if ratio:
            size = [int(x * ratio) for x in image.size]
            image = image.resize(size, Image.ANTIALIAS)
            return self.fit_image(image)
        return image

    def set_elements(self):
        &#34;&#34;&#34;Return elements used in game.

        It contain list of allowed elements in game. At first load images from
        their directory then fill missing elements by drawing 2D figures
        picked from elements list according to game settings (amount).
        Returned elements are gathered in dictionary with their names and
        color code or image.
        &#34;&#34;&#34;
        amount = self.settings[&#39;figures&#39;]
        images = self.get_images()
        if len(images) &lt; amount:
            figures = self.adjust_elements(
                [&#39;square&#39;, &#39;triangle&#39;, &#39;octagon&#39;, &#39;diamond&#39;],
                amount - len(images)
            )
            return {**images, **figures}
        else:
            picked = sample(list(images), amount)
            return {x: images[x] for x in picked}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="memorizeit.game.Game" href="#memorizeit.game.Game">Game</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="memorizeit.game.Static.fit_image"><code class="name flex">
<span>def <span class="ident">fit_image</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<section class="desc"><p>Scale image.</p>
<p>Lower width or height of image as long as it will fit dedicated place
on screen (calculated from monitor resolution).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>PIL.Image</code></dt>
<dd>image representation from PIL library</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>scaled image represented by PIL</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L271-L294" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fit_image(self, image):
    &#34;&#34;&#34;Scale image.

    Lower width or height of image as long as it will fit dedicated place
    on screen (calculated from monitor resolution).

    Parameters
    ----------
    image : PIL.Image
        image representation from PIL library

    Returns
    -------
    PIL.Image
        scaled image represented by PIL
    &#34;&#34;&#34;
    x, y = [x / 5 for x in self.resolution]
    w, h = image.size
    ratio = x / w if x &lt; w else y / h if y &lt; h else False
    if ratio:
        size = [int(x * ratio) for x in image.size]
        image = image.resize(size, Image.ANTIALIAS)
        return self.fit_image(image)
    return image</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Static.get_images"><code class="name flex">
<span>def <span class="ident">get_images</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Load images from their directory ('memorizeit/img/elements/').</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dictionary with image name and its representation as
<code>pygame.Surface</code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L235-L251" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_images(self):
    &#34;&#34;&#34;Load images from their directory (&#39;memorizeit/img/elements/&#39;).

    Returns
    -------
    dict
        dictionary with image name and its representation as
        `pygame.Surface`
    &#34;&#34;&#34;
    images = {}
    try:
        path = Path(__file__).parent.absolute() / &#39;img&#39; / &#39;elements&#39;
        for image in path.iterdir():
            images[image.stem] = self.load_image(image)
    except OSError:
        pass
    return images</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Static.load_image"><code class="name flex">
<span>def <span class="ident">load_image</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"><p>Load image from set path and scale it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>pathlib.Path</code></dt>
<dd>location of image to load</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pygame.Surface</code></dt>
<dd>information about loaded and scaled image represented as
<code>pygame.Surface</code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L253-L269" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load_image(self, path):
    &#34;&#34;&#34;Load image from set path and scale it.

    Parameters
    ----------
    path : pathlib.Path
        location of image to load

    Returns
    -------
    pygame.Surface
        information about loaded and scaled image represented as
        `pygame.Surface`
    &#34;&#34;&#34;
    image = Image.open(path)
    image = self.fit_image(image)
    return pygame.image.fromstring(image.tobytes(), image.size, image.mode)</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Static.prepare_environment"><code class="name flex">
<span>def <span class="ident">prepare_environment</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Set basics needed to launch 2D game mode.</p>
<p>Specify attribute used only in static game mode - screen. Extend
attribute timer by interval allowing to control spawning new 2D waves
on screen.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L206-L218" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def prepare_environment(self):
    &#34;&#34;&#34;Set basics needed to launch 2D game mode.

    Specify attribute used only in static game mode - screen. Extend
    attribute timer by interval allowing to control spawning new 2D waves
    on screen.
    &#34;&#34;&#34;
    self.screen = pygame.display.set_mode(
        self.resolution,
        pygame.FULLSCREEN
    )
    self.timer[&#39;interval&#39;] = self.timer[&#39;start&#39;]
    self.wave = self.create_wave(Wave2D, self.screen, self.resolution)</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Static.run_game"><code class="name flex">
<span>def <span class="ident">run_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Spawn waves of 2D figures based on time interval.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L220-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_game(self):
    &#34;&#34;&#34;Spawn waves of 2D figures based on time interval.&#34;&#34;&#34;
    if self.is_wave_finished(
            time() &gt; self.timer[&#39;interval&#39;] + self.timer[&#39;wave&#39;]
    ):
        self.timer[&#39;interval&#39;] += self.timer[&#39;wave&#39;]
        self.spawn_new_wave()
    else:
        self.wave()</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Static.set_elements"><code class="name flex">
<span>def <span class="ident">set_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return elements used in game.</p>
<p>It contain list of allowed elements in game. At first load images from
their directory then fill missing elements by drawing 2D figures
picked from elements list according to game settings (amount).
Returned elements are gathered in dictionary with their names and
color code or image.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L296-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_elements(self):
    &#34;&#34;&#34;Return elements used in game.

    It contain list of allowed elements in game. At first load images from
    their directory then fill missing elements by drawing 2D figures
    picked from elements list according to game settings (amount).
    Returned elements are gathered in dictionary with their names and
    color code or image.
    &#34;&#34;&#34;
    amount = self.settings[&#39;figures&#39;]
    images = self.get_images()
    if len(images) &lt; amount:
        figures = self.adjust_elements(
            [&#39;square&#39;, &#39;triangle&#39;, &#39;octagon&#39;, &#39;diamond&#39;],
            amount - len(images)
        )
        return {**images, **figures}
    else:
        picked = sample(list(images), amount)
        return {x: images[x] for x in picked}</code></pre>
</details>
</dd>
<dt id="memorizeit.game.Static.spawn_new_wave"><code class="name flex">
<span>def <span class="ident">spawn_new_wave</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Clear screen and spawn new wave of figures or images.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethru/memorizeit/blob/89314c29ad839a7e7e05f0ea1204b81c1bea302c/memorizeit/game.py#L230-L233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def spawn_new_wave(self):
    &#34;&#34;&#34;Clear screen and spawn new wave of figures or images.&#34;&#34;&#34;
    self.screen.fill((0, 0, 0))
    self.wave = self.create_wave(Wave2D, self.screen, self.resolution)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="memorizeit.game.Game" href="#memorizeit.game.Game">Game</a></b></code>:
<ul class="hlist">
<li><code><a title="memorizeit.game.Game.adjust_elements" href="#memorizeit.game.Game.adjust_elements">adjust_elements</a></code></li>
<li><code><a title="memorizeit.game.Game.create_timer" href="#memorizeit.game.Game.create_timer">create_timer</a></code></li>
<li><code><a title="memorizeit.game.Game.create_wave" href="#memorizeit.game.Game.create_wave">create_wave</a></code></li>
<li><code><a title="memorizeit.game.Game.has_time_left" href="#memorizeit.game.Game.has_time_left">has_time_left</a></code></li>
<li><code><a title="memorizeit.game.Game.is_wave_finished" href="#memorizeit.game.Game.is_wave_finished">is_wave_finished</a></code></li>
<li><code><a title="memorizeit.game.Game.pick_element" href="#memorizeit.game.Game.pick_element">pick_element</a></code></li>
<li><code><a title="memorizeit.game.Game.play_sound" href="#memorizeit.game.Game.play_sound">play_sound</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header><img src="https://raw.githubusercontent.com/ethru/memorizeit/master/img/brain.png" alt=""></header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#game">Game</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="memorizeit" href="index.html">memorizeit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="memorizeit.game.Dynamic" href="#memorizeit.game.Dynamic">Dynamic</a></code></h4>
<ul class="two-column">
<li><code><a title="memorizeit.game.Dynamic.get_speed" href="#memorizeit.game.Dynamic.get_speed">get_speed</a></code></li>
<li><code><a title="memorizeit.game.Dynamic.move_view" href="#memorizeit.game.Dynamic.move_view">move_view</a></code></li>
<li><code><a title="memorizeit.game.Dynamic.prepare_environment" href="#memorizeit.game.Dynamic.prepare_environment">prepare_environment</a></code></li>
<li><code><a title="memorizeit.game.Dynamic.run_game" href="#memorizeit.game.Dynamic.run_game">run_game</a></code></li>
<li><code><a title="memorizeit.game.Dynamic.set_elements" href="#memorizeit.game.Dynamic.set_elements">set_elements</a></code></li>
<li><code><a title="memorizeit.game.Dynamic.spawn_new_wave" href="#memorizeit.game.Dynamic.spawn_new_wave">spawn_new_wave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.game.Game" href="#memorizeit.game.Game">Game</a></code></h4>
<ul class="two-column">
<li><code><a title="memorizeit.game.Game.adjust_elements" href="#memorizeit.game.Game.adjust_elements">adjust_elements</a></code></li>
<li><code><a title="memorizeit.game.Game.create_timer" href="#memorizeit.game.Game.create_timer">create_timer</a></code></li>
<li><code><a title="memorizeit.game.Game.create_wave" href="#memorizeit.game.Game.create_wave">create_wave</a></code></li>
<li><code><a title="memorizeit.game.Game.has_time_left" href="#memorizeit.game.Game.has_time_left">has_time_left</a></code></li>
<li><code><a title="memorizeit.game.Game.is_wave_finished" href="#memorizeit.game.Game.is_wave_finished">is_wave_finished</a></code></li>
<li><code><a title="memorizeit.game.Game.pick_element" href="#memorizeit.game.Game.pick_element">pick_element</a></code></li>
<li><code><a title="memorizeit.game.Game.play_sound" href="#memorizeit.game.Game.play_sound">play_sound</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="memorizeit.game.Static" href="#memorizeit.game.Static">Static</a></code></h4>
<ul class="two-column">
<li><code><a title="memorizeit.game.Static.fit_image" href="#memorizeit.game.Static.fit_image">fit_image</a></code></li>
<li><code><a title="memorizeit.game.Static.get_images" href="#memorizeit.game.Static.get_images">get_images</a></code></li>
<li><code><a title="memorizeit.game.Static.load_image" href="#memorizeit.game.Static.load_image">load_image</a></code></li>
<li><code><a title="memorizeit.game.Static.prepare_environment" href="#memorizeit.game.Static.prepare_environment">prepare_environment</a></code></li>
<li><code><a title="memorizeit.game.Static.run_game" href="#memorizeit.game.Static.run_game">run_game</a></code></li>
<li><code><a title="memorizeit.game.Static.set_elements" href="#memorizeit.game.Static.set_elements">set_elements</a></code></li>
<li><code><a title="memorizeit.game.Static.spawn_new_wave" href="#memorizeit.game.Static.spawn_new_wave">spawn_new_wave</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
